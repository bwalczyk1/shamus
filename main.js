/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Bullet.ts":
/*!***********************!*\
  !*** ./src/Bullet.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Bullet = /** @class */ (function () {\r\n    function Bullet(id, movementForces) {\r\n        this.speed = 9;\r\n        this.id = id;\r\n        if (movementForces[0] == 0) {\r\n            this.type = \"vertical\";\r\n        }\r\n        else if (movementForces[1] == 0) {\r\n            this.type = \"horizontal\";\r\n        }\r\n        else if (movementForces[0] == movementForces[1]) {\r\n            this.type = \"diagonal\";\r\n        }\r\n        else {\r\n            this.type = \"diagonalInverted\";\r\n        }\r\n        this.speedX = movementForces[0] * this.speed;\r\n        this.speedY = movementForces[1] * this.speed;\r\n        if (this.type == \"horizontal\") {\r\n            this.width = 8;\r\n            this.height = 3;\r\n        }\r\n        else if (this.type == \"vertical\") {\r\n            this.width = 4;\r\n            this.height = 6;\r\n        }\r\n        else if (this.type == \"diagonal\" || this.type == \"diagonalInverted\") {\r\n            this.width = 4;\r\n            this.height = 4;\r\n        }\r\n    }\r\n    Bullet.prototype.setCoords = function (x, y) {\r\n        this.collisionRect = { x: x - this.speedX, y: y - this.speedY, width: this.width, height: this.height };\r\n    };\r\n    Bullet.prototype.move = function () {\r\n        this.collisionRect.x += this.speedX;\r\n        this.collisionRect.y += this.speedY;\r\n    };\r\n    return Bullet;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Bullet);\r\n\n\n//# sourceURL=webpack://shamus/./src/Bullet.ts?");

/***/ }),

/***/ "./src/Enemy.ts":
/*!**********************!*\
  !*** ./src/Enemy.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Enemy = /** @class */ (function () {\r\n    function Enemy(type) {\r\n        this.collisionRect = { x: 0, y: 0, width: 16, height: 8 };\r\n        this.movementObject = { endFrame: 0, forceX: 0, forceY: 0 };\r\n        this.type = type;\r\n        var availableColors;\r\n        switch (type) {\r\n            case 0:\r\n                availableColors = [\"red\", 'green', 'blue', 'white'];\r\n                this.speed = 3;\r\n                break;\r\n            case 1:\r\n                availableColors = [\"yellow\"];\r\n                //availableColors = [\"yellow\", \"cyan\", 'white']\r\n                this.speed = 2;\r\n                break;\r\n            default:\r\n                availableColors = [\"green\"];\r\n                this.collisionRect = { x: 0, y: 0, width: 12, height: 8 };\r\n                this.speed = 16;\r\n                break;\r\n        }\r\n        this.color = availableColors[Math.floor(Math.random() * availableColors.length)];\r\n    }\r\n    Enemy.prototype.setPosition = function (x, y) {\r\n        this.collisionRect.x = x;\r\n        this.collisionRect.y = y;\r\n    };\r\n    Enemy.prototype.equals = function (enemy) {\r\n        if (this.collisionRect.x == enemy.collisionRect.x && this.collisionRect.y == enemy.collisionRect.y) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    return Enemy;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Enemy);\r\n\n\n//# sourceURL=webpack://shamus/./src/Enemy.ts?");

/***/ }),

/***/ "./src/EnemyBullet.ts":
/*!****************************!*\
  !*** ./src/EnemyBullet.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar EnemyBullet = /** @class */ (function () {\r\n    function EnemyBullet(id, x, y, movementForceX, movementForceY) {\r\n        this.speed = 7;\r\n        this.id = id;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.speedX = movementForceX * this.speed;\r\n        this.speedY = movementForceY * this.speed;\r\n    }\r\n    EnemyBullet.prototype.move = function () {\r\n        this.x += this.speedX;\r\n        this.y += this.speedY;\r\n    };\r\n    return EnemyBullet;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EnemyBullet);\r\n\n\n//# sourceURL=webpack://shamus/./src/EnemyBullet.ts?");

/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Bullet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bullet */ \"./src/Bullet.ts\");\n/* harmony import */ var _Enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enemy */ \"./src/Enemy.ts\");\n/* harmony import */ var _EnemyBullet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EnemyBullet */ \"./src/EnemyBullet.ts\");\n/* harmony import */ var _Room__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Room */ \"./src/Room.ts\");\n\r\n\r\n\r\n\r\nvar Game = /** @class */ (function () {\r\n    function Game() {\r\n        var _this = this;\r\n        this.frame = 0;\r\n        this.animationFrame = 0;\r\n        this.frameLength = 100;\r\n        this.rooms = [];\r\n        this.playerCollisionRect = { x: 0, y: 0, width: 14, height: 17 };\r\n        this.shadowCollisionRect = { x: 0, y: 0, width: 18, height: 15 };\r\n        this.basicSpeed = 1;\r\n        this.playerSpeed = this.basicSpeed;\r\n        this.shadowSpeed = 7;\r\n        this.shadowFreezeTime = 0;\r\n        this.playerMovementsObject = {};\r\n        this.enemies = [];\r\n        this.lastStartPosition = [16, Math.floor(176 / 2 - this.playerCollisionRect.height / 2)];\r\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\r\n        this.isFireModeOn = false;\r\n        this.isGunLoaded = true;\r\n        this.playerBullets = [];\r\n        this.enemyBullets = [];\r\n        this.playerLives = 4;\r\n        this.score = 0;\r\n        this.highScore = 0;\r\n        this.bulletsFired = 0;\r\n        this.roomsTraveledSinceInjured = 0;\r\n        this.keys = [];\r\n        this.roomsOfFoundKeys = [];\r\n        this.bulletsAnimations = [];\r\n        this.startTime = Date.now();\r\n        this.gameScreen = document.getElementById(\"gameScreen\");\r\n        // this.gameScreen.style.width = document.body.style.width;\r\n        // this.gameScreen.style.height = document.body.style.height;\r\n        this.ctx = this.gameScreen.getContext('2d');\r\n        this.ctx.imageSmoothingEnabled = false;\r\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_3__[\"default\"](10, \"black\", \"yellow\", [\r\n            { x: 0, y: 64, width: 8, height: 48 },\r\n            { x: 0, y: 56, width: 56, height: 8 },\r\n            { x: 48, y: 8, width: 8, height: 48 },\r\n            { x: 48, y: 0, width: 224, height: 8 },\r\n            { x: 264, y: 8, width: 8, height: 48 },\r\n            { x: 264, y: 56, width: 56, height: 8 },\r\n            { x: 264, y: 112, width: 56, height: 8 },\r\n            { x: 264, y: 120, width: 8, height: 48 },\r\n            { x: 48, y: 168, width: 224, height: 8 },\r\n            { x: 48, y: 120, width: 8, height: 48 },\r\n            { x: 0, y: 112, width: 128, height: 8 },\r\n            { x: 120, y: 56, width: 8, height: 56 },\r\n            { x: 128, y: 56, width: 64, height: 8 },\r\n            { x: 192, y: 56, width: 8, height: 56 }\r\n        ], [null, 1, null, null], \"blue\", \"\"));\r\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_3__[\"default\"](21, \"black\", \"yellow\", [\r\n            { x: 320 - 8, y: 56 + 8, width: 8, height: 112 - 56 - 8 },\r\n            { x: 0, y: 112, width: 320, height: 8 },\r\n            { x: 0, y: 56, width: 320, height: 8 }\r\n        ], [null, null, null, 0], \"\", \"blue\"));\r\n        this.playerCollisionRect.x = this.lastStartPosition[0];\r\n        this.playerCollisionRect.y = this.lastStartPosition[1];\r\n        this.setNewRoom(0);\r\n        document.addEventListener(\"keydown\", function (event) { _this.playerDetectAction(event); });\r\n        document.addEventListener(\"keyup\", function (event) { _this.playerStopAction(event); });\r\n        // setInterval(() => {this.refreshScreen()}, this.frameLength)\r\n        window.requestAnimationFrame(function () { return _this.refreshScreen(); });\r\n    }\r\n    Game.prototype.refreshScreen = function () {\r\n        var _this = this;\r\n        // console.log(this.playerCollisionRect.x)\r\n        this.ctx = this.gameScreen.getContext('2d');\r\n        this.ctx.clearRect(0, 0, 320, 208);\r\n        // this.ctx.fillStyle = \"black\"\r\n        // this.ctx.fillRect(0, 0, 320, 208)\r\n        //Detect room change\r\n        if (this.playerCollisionRect.y < 0) {\r\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[0]);\r\n        }\r\n        else if (this.playerCollisionRect.x + this.playerCollisionRect.width > 320) {\r\n            this.playerCollisionRect.x = 16;\r\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[1]);\r\n        }\r\n        else if (this.playerCollisionRect.y + this.playerCollisionRect.height > 176) {\r\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[2]);\r\n        }\r\n        else if (this.playerCollisionRect.x < 0) {\r\n            this.playerCollisionRect.x = 320 - 16 - this.playerCollisionRect.width;\r\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[3]);\r\n        }\r\n        // Draw shadow and detect collision with player\r\n        if (Date.now() - this.timeOfEnteringRoom >= 15000) {\r\n            var isShadowFrozen = (Date.now() - this.shadowFreezeTime <= 2500);\r\n            var isShadowInMmove = Date.now() - this.timeOfEnteringRoom >= 17500;\r\n            if (isShadowInMmove && !isShadowFrozen && this.canReallyAnimate()) {\r\n                var newX = void 0, newY = void 0;\r\n                if (this.frame % 2 == 1) {\r\n                    newX = this.shadowCollisionRect.x - 2;\r\n                    newY = this.shadowCollisionRect.y + 2;\r\n                    this.shadowCollisionRect = { x: newX, y: newY, width: 22, height: 11 };\r\n                }\r\n                else {\r\n                    newX = this.shadowCollisionRect.x + 2;\r\n                    newY = this.shadowCollisionRect.y - 2;\r\n                    this.shadowCollisionRect = { x: newX, y: newY, width: 18, height: 15 };\r\n                }\r\n                this.moveShadow();\r\n            }\r\n            var shadowImg = document.createElement('img');\r\n            if (isShadowFrozen) {\r\n                shadowImg.src = './assets/enemies/shadow/frozen' + this.shadowFreezeTime % 2 + '.png';\r\n            }\r\n            else if (isShadowInMmove) {\r\n                shadowImg.src = './assets/enemies/shadow/' + this.frame % 2 + '.png';\r\n            }\r\n            else {\r\n                shadowImg.src = './assets/enemies/shadow/0.png';\r\n            }\r\n            this.ctx.drawImage(shadowImg, this.shadowCollisionRect.x, this.shadowCollisionRect.y);\r\n            if (this.isCollisionDetected(this.shadowCollisionRect, this.playerCollisionRect)) {\r\n                this.takeDamage();\r\n                return;\r\n            }\r\n        }\r\n        // Draw background\r\n        var wallImg = document.createElement('img');\r\n        wallImg.src = './assets/background/' + this.currentRoom.bgColor + '.png';\r\n        for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\r\n            var backgroundLine = _a[_i];\r\n            for (var i = 0; i < backgroundLine.width; i += 8) {\r\n                this.ctx.drawImage(wallImg, backgroundLine.x + i, backgroundLine.y);\r\n            }\r\n        }\r\n        // Draw walls and detect their collisions with player\r\n        for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n            var wall = _c[_b];\r\n            if (this.currentRoom.levelColor == \"black\") {\r\n                this.ctx.fillStyle = \"white\";\r\n            }\r\n            else {\r\n                this.ctx.fillStyle = this.currentRoom.levelColor;\r\n            }\r\n            if (this.isCollisionDetected(wall, this.playerCollisionRect)) {\r\n                this.takeDamage();\r\n                return;\r\n            }\r\n            this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);\r\n            this.ctx.fillStyle = \"blue\";\r\n            if (wall == this.currentRoom.wallCollisionRects[0]) {\r\n                var realFrame = this.frame - (wall.y - (this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height)) / 2;\r\n                for (var i = 0; i < wall.height; i += 8) {\r\n                    this.ctx.fillRect(wall.x, wall.y + i + realFrame % 4 * 2, wall.width, 2);\r\n                }\r\n            }\r\n            else if (wall.width >= wall.height) {\r\n                for (var i = 0; i < wall.width; i += 8) {\r\n                    this.ctx.fillRect(wall.x + i + this.frame % 4 * 2, wall.y, 2, wall.height);\r\n                }\r\n            }\r\n            else {\r\n                for (var i = 0; i < wall.height; i += 8) {\r\n                    this.ctx.fillRect(wall.x, wall.y + i + this.frame % 4 * 2, wall.width, 2);\r\n                }\r\n            }\r\n        }\r\n        // Draw interface\r\n        // Highscore\r\n        this.ctx.clearRect(0, 2 * 8, 6 * 8, 8);\r\n        var highScoreString = this.highScore.toString();\r\n        for (var i = 0; i < highScoreString.length; i++) {\r\n            var digitString = highScoreString[i];\r\n            var digitImg = document.createElement('img');\r\n            digitImg.src = './assets/highscoreDigits/' + digitString + '.png';\r\n            var digitX = 6 * 8 - (highScoreString.length - i) * 8;\r\n            this.ctx.drawImage(digitImg, digitX, 2 * 8);\r\n        }\r\n        // Score\r\n        this.ctx.clearRect(0, 4 * 8, 6 * 8, 8);\r\n        var scoreString = this.score.toString();\r\n        for (var i = 0; i < scoreString.length; i++) {\r\n            var digitString = scoreString[i];\r\n            var digitImg = document.createElement('img');\r\n            digitImg.src = './assets/digits/' + digitString + '.png';\r\n            var digitX = 6 * 8 - (scoreString.length - i) * 8;\r\n            this.ctx.drawImage(digitImg, digitX, 4 * 8);\r\n        }\r\n        // Lives\r\n        this.ctx.clearRect(320 - 6 * 8, 8, 6 * 8, 6 * 8);\r\n        var lifeImg = document.createElement('img');\r\n        lifeImg.src = './assets/playerLife.png';\r\n        for (var i = 1; i <= this.playerLives; i++) {\r\n            this.ctx.drawImage(lifeImg, 320 - 6 * 8 + (i - 1) % 3 * 16, 8 + Math.floor((i - 1) / 3) * 16);\r\n        }\r\n        // Room info and inventory\r\n        this.ctx.clearRect(0, 208 - 4 * 8, 320, 4 * 8);\r\n        // - Keys\r\n        if (this.keys.includes(\"blue\")) {\r\n            var blueKeyImage = document.createElement('img');\r\n            blueKeyImage.src = './assets/keys/blue.png';\r\n            this.ctx.drawImage(blueKeyImage, 7 * 16 + 1, 176 + 1);\r\n        }\r\n        // - Room info\r\n        var interfaceImage = document.createElement('img');\r\n        interfaceImage.src = './assets/interface.png';\r\n        this.ctx.drawImage(interfaceImage, 8 + 1, 176 + 8);\r\n        // - Room number\r\n        var roomString = this.currentRoom.id.toString();\r\n        for (var i = 0; i < roomString.length; i++) {\r\n            var digitString = roomString[i];\r\n            var digitImg = document.createElement('img');\r\n            digitImg.src = './assets/digits/' + digitString + '.png';\r\n            var digitX = (7 + i) * 8;\r\n            this.ctx.drawImage(digitImg, digitX, 176 + 8);\r\n        }\r\n        // Draw player\r\n        var playerImg = document.createElement('img');\r\n        if (this.playerMovementsObject.goRight) {\r\n            playerImg.src = './assets/player/right/' + (this.frame % 2) + '.png';\r\n        }\r\n        else if (this.playerMovementsObject.goLeft) {\r\n            playerImg.src = './assets/player/left/' + (this.frame % 2) + '.png';\r\n        }\r\n        else if (this.playerMovementsObject.goUp || this.playerMovementsObject.goDown) {\r\n            playerImg.src = './assets/player/vert/' + (this.frame % 2) + '.png';\r\n        }\r\n        else {\r\n            playerImg.src = './assets/player/still.png';\r\n        }\r\n        this.ctx.drawImage(playerImg, this.playerCollisionRect.x, this.playerCollisionRect.y);\r\n        // Move enemies\r\n        if (this.canReallyAnimate()) {\r\n            this.moveEnemies();\r\n            this.fireEnemyBullets();\r\n        }\r\n        // console.log('bb')\r\n        // Draw enemies and detect their collisions with player\r\n        for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\r\n            var enemy = _e[_d];\r\n            if (this.isCollisionDetected(this.playerCollisionRect, enemy.collisionRect)) {\r\n                this.takeDamage();\r\n                return;\r\n            }\r\n            else {\r\n                // this.ctx.fillStyle = enemy.color\r\n                // this.ctx.fillRect(enemy.collisionRect.x, enemy.collisionRect.y, enemy.collisionRect.width, enemy.collisionRect.height)\r\n                var enemyPhase = this.frame % 4;\r\n                var enemyImg = document.createElement('img');\r\n                switch (enemy.type) {\r\n                    case 0:\r\n                        enemyImg.src = './assets/enemies/drone/' + enemy.color + '/' + enemyPhase + '.png';\r\n                        break;\r\n                    case 1:\r\n                        var droidMovementPhase = void 0;\r\n                        if (enemy.movementObject.forceX != 0)\r\n                            droidMovementPhase = enemyPhase % 2;\r\n                        else if (enemy.movementObject.forceY != 0)\r\n                            droidMovementPhase = enemyPhase % 2 + 1;\r\n                        else\r\n                            droidMovementPhase = enemyPhase % 2 * 2;\r\n                        enemyImg.src = './assets/enemies/droid/' + enemy.color + '/' + enemyPhase + '_' + droidMovementPhase + '.png';\r\n                        break;\r\n                    default:\r\n                        enemyImg.src = './assets/enemies/jumper/' + enemyPhase + '.png';\r\n                        break;\r\n                }\r\n                this.ctx.drawImage(enemyImg, enemy.collisionRect.x, enemy.collisionRect.y);\r\n            }\r\n        }\r\n        // Move and draw bullets\r\n        this.ctx.fillStyle = \"medium turquoise\";\r\n        for (var _f = 0, _g = this.enemyBullets; _f < _g.length; _f++) {\r\n            var enemyBullet = _g[_f];\r\n            if (this.canReallyAnimate())\r\n                enemyBullet.move();\r\n            this.ctx.fillRect(enemyBullet.x, enemyBullet.y, 2, 2);\r\n        }\r\n        for (var _h = 0, _j = this.playerBullets; _h < _j.length; _h++) {\r\n            var bullet = _j[_h];\r\n            if (this.canReallyAnimate())\r\n                bullet.move();\r\n            var bulletImg = document.createElement('img');\r\n            bulletImg.src = './assets/bullets/' + bullet.type + '.png';\r\n            if (bullet.type == \"diagonal\" || bullet.type == \"diagonalInverted\") {\r\n                this.ctx.drawImage(bulletImg, bullet.collisionRect.x - 1, bullet.collisionRect.y - 1);\r\n            }\r\n            else {\r\n                this.ctx.drawImage(bulletImg, bullet.collisionRect.x, bullet.collisionRect.y);\r\n            }\r\n        }\r\n        // Draw key and detect its collision with player\r\n        if (this.currentRoom.keyColor != \"\" && !this.roomsOfFoundKeys.includes(this.currentRoom.id)) {\r\n            var keyImage = document.createElement('img');\r\n            keyImage.src = './assets/keys/' + this.currentRoom.keyColor + '.png';\r\n            this.ctx.drawImage(keyImage, this.keyCollisionRect.x, this.keyCollisionRect.y);\r\n            if (this.isCollisionDetected(this.playerCollisionRect, this.keyCollisionRect)) {\r\n                this.keys.push(this.currentRoom.keyColor);\r\n                this.roomsOfFoundKeys.push(this.currentRoom.id);\r\n            }\r\n        }\r\n        // Draw keyhole and detect its collision with player\r\n        if (this.currentRoom.keyHoleColor != \"\" && this.currentRoom.wallCollisionRects[0].y == this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height) {\r\n            var keyHoleImg = document.createElement('img');\r\n            keyHoleImg.src = './assets/keyholes/' + this.currentRoom.keyHoleColor + '.png';\r\n            this.ctx.drawImage(keyHoleImg, this.keyHoleCollisionRect.x, this.keyHoleCollisionRect.y);\r\n            if (this.isCollisionDetected(this.playerCollisionRect, this.keyHoleCollisionRect) && this.keys.includes(this.currentRoom.keyHoleColor)) {\r\n                var newKeys = [];\r\n                for (var _k = 0, _l = this.keys; _k < _l.length; _k++) {\r\n                    var keyColor = _l[_k];\r\n                    if (keyColor != this.currentRoom.keyHoleColor) {\r\n                        newKeys.push(keyColor);\r\n                    }\r\n                }\r\n                this.keys = newKeys;\r\n                this.openingWallInterval = setInterval(function () {\r\n                    if (_this.currentRoom.keyHoleColor != \"\") {\r\n                        _this.currentRoom.wallCollisionRects[0].y += 1;\r\n                        _this.currentRoom.wallCollisionRects[0].height -= 1;\r\n                        if (_this.currentRoom.wallCollisionRects[0].height == 0) {\r\n                            clearInterval(_this.openingWallInterval);\r\n                            _this.openingWallInterval = null;\r\n                        }\r\n                    }\r\n                }, this.frameLength / 2);\r\n            }\r\n        }\r\n        // Draw bullets explosion animations\r\n        var newBulletsAnimations = [];\r\n        for (var _m = 0, _o = this.bulletsAnimations; _m < _o.length; _m++) {\r\n            var bulletAnimation = _o[_m];\r\n            if (this.frame - bulletAnimation.startFrame < 4) {\r\n                var bulletAnimationImage = document.createElement('img');\r\n                bulletAnimationImage.src = './assets/bulletExplosions/' + (this.frame - bulletAnimation.startFrame) + '.png';\r\n                this.ctx.drawImage(bulletAnimationImage, bulletAnimation.x, bulletAnimation.y);\r\n                newBulletsAnimations.push(bulletAnimation);\r\n            }\r\n        }\r\n        this.bulletsAnimations = newBulletsAnimations;\r\n        // Detect bullets' collisions with shadow, walls and enemies\r\n        var bulletsToDelete = [];\r\n        var enemyBulletsToDelete = [];\r\n        var enemiesToDelete = [];\r\n        for (var _p = 0, _q = this.playerBullets; _p < _q.length; _p++) {\r\n            var bullet = _q[_p];\r\n            if (bullet.collisionRect.x + bullet.collisionRect.width < 0 || bullet.collisionRect.x > 320 || bullet.collisionRect.y + bullet.collisionRect.height < 0 || bullet.collisionRect.y > 176) {\r\n                bulletsToDelete.push(bullet);\r\n            }\r\n            else {\r\n                if (this.isCollisionDetected(bullet.collisionRect, this.shadowCollisionRect)) {\r\n                    var bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\r\n                    var bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\r\n                    var bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\r\n                    for (var _r = 0, _s = this.enemies; _r < _s.length; _r++) {\r\n                        var neighbourEnemy = _s[_r];\r\n                        if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\r\n                            enemiesToDelete.push(neighbourEnemy);\r\n                        }\r\n                    }\r\n                    this.shadowFreezeTime = Math.floor(Date.now() / 2) * 2;\r\n                    bulletsToDelete.push(bullet);\r\n                    this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\r\n                }\r\n                else {\r\n                    for (var _t = 0, _u = this.currentRoom.wallCollisionRects; _t < _u.length; _t++) {\r\n                        var wall = _u[_t];\r\n                        if (this.isCollisionDetected(bullet.collisionRect, wall)) {\r\n                            var bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\r\n                            var bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\r\n                            bulletsToDelete.push(bullet);\r\n                            this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\r\n                        for (var _v = 0, _w = this.enemies; _v < _w.length; _v++) {\r\n                            var enemy = _w[_v];\r\n                            if (this.isCollisionDetected(bullet.collisionRect, enemy.collisionRect)) {\r\n                                var bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\r\n                                var bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\r\n                                var bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\r\n                                for (var _x = 0, _y = this.enemies; _x < _y.length; _x++) {\r\n                                    var neighbourEnemy = _y[_x];\r\n                                    if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\r\n                                        enemiesToDelete.push(neighbourEnemy);\r\n                                    }\r\n                                }\r\n                                bulletsToDelete.push(bullet);\r\n                                this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (var _z = 0, _0 = this.enemyBullets; _z < _0.length; _z++) {\r\n            var enemyBullet = _0[_z];\r\n            if (enemyBullet.x + 2 < 0 || enemyBullet.x > 320 || enemyBullet.y + 2 < 0 || enemyBullet.y > 176) {\r\n                enemyBulletsToDelete.push(enemyBullet);\r\n            }\r\n            else {\r\n                var EBCollisionRect = { x: enemyBullet.x, y: enemyBullet.y, width: 2, height: 2 };\r\n                if (this.isCollisionDetected(EBCollisionRect, this.playerCollisionRect)) {\r\n                    this.takeDamage();\r\n                    return;\r\n                }\r\n                for (var _1 = 0, _2 = this.currentRoom.wallCollisionRects; _1 < _2.length; _1++) {\r\n                    var wall = _2[_1];\r\n                    if (this.isCollisionDetected(EBCollisionRect, wall)) {\r\n                        enemyBulletsToDelete.push(enemyBullet);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!this.bulletArrayIncludes(enemyBulletsToDelete, enemyBullet)) {\r\n                    for (var _3 = 0, _4 = this.enemies; _3 < _4.length; _3++) {\r\n                        var enemy = _4[_3];\r\n                        if (this.isCollisionDetected(EBCollisionRect, enemy.collisionRect)) {\r\n                            if (!this.enemyArrayIncludes(enemiesToDelete, enemy)) {\r\n                                enemiesToDelete.push(enemy);\r\n                            }\r\n                            enemyBulletsToDelete.push(enemyBullet);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.score += 5 * enemiesToDelete.length;\r\n        if (enemiesToDelete.length == this.enemies.length && enemiesToDelete.length > 0) {\r\n            this.score += 200;\r\n            this.playerSpeed *= 2;\r\n        }\r\n        if (this.score > this.highScore) {\r\n            this.highScore = this.score;\r\n        }\r\n        var newEnemies = [];\r\n        for (var _5 = 0, _6 = this.enemies; _5 < _6.length; _5++) {\r\n            var enemy = _6[_5];\r\n            if (!this.enemyArrayIncludes(enemiesToDelete, enemy)) {\r\n                newEnemies.push(enemy);\r\n            }\r\n        }\r\n        this.enemies = newEnemies;\r\n        var newBullets = [];\r\n        for (var _7 = 0, _8 = this.playerBullets; _7 < _8.length; _7++) {\r\n            var bullet = _8[_7];\r\n            if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\r\n                newBullets.push(bullet);\r\n            }\r\n        }\r\n        this.playerBullets = newBullets;\r\n        var newEnemyBullets = [];\r\n        for (var _9 = 0, _10 = this.enemyBullets; _9 < _10.length; _9++) {\r\n            var enemyBullet = _10[_9];\r\n            if (!this.bulletArrayIncludes(enemyBulletsToDelete, enemyBullet)) {\r\n                newEnemyBullets.push(enemyBullet);\r\n            }\r\n        }\r\n        this.enemyBullets = newEnemyBullets;\r\n        if (this.canReallyAnimate())\r\n            this.frame += 1;\r\n        this.animationFrame += 1;\r\n        // console.log('aa')\r\n        window.requestAnimationFrame(function () { return _this.refreshScreen(); });\r\n    };\r\n    Game.prototype.setNewRoom = function (roomId) {\r\n        this.currentRoom = this.rooms[roomId];\r\n        this.playerSpeed = this.basicSpeed;\r\n        this.lastStartPosition = [this.playerCollisionRect.x, this.playerCollisionRect.y];\r\n        this.placeShadow();\r\n        this.createRoomBackground();\r\n        this.enemies = [];\r\n        this.playerBullets = [];\r\n        this.enemyBullets = [];\r\n        this.createEnemies(1);\r\n        this.placeKey();\r\n        this.placeKeyHole();\r\n        this.timeOfEnteringRoom = Date.now();\r\n        this.roomsTraveledSinceInjured += 1;\r\n        console.log(this.roomsTraveledSinceInjured);\r\n    };\r\n    Game.prototype.takeDamage = function () {\r\n        var _this = this;\r\n        this.playerSpeed = this.basicSpeed;\r\n        this.placeShadow();\r\n        if (this.playerLives == 0) {\r\n            this.die();\r\n        }\r\n        else {\r\n            this.playerLives--;\r\n            this.playerCollisionRect.x = this.lastStartPosition[0];\r\n            this.playerCollisionRect.y = this.lastStartPosition[1];\r\n            this.enemies = [];\r\n            this.playerBullets = [];\r\n            this.enemyBullets = [];\r\n            this.createEnemies(1);\r\n            this.placeKey();\r\n            this.placeKeyHole();\r\n            this.timeOfEnteringRoom = Date.now();\r\n        }\r\n        this.roomsTraveledSinceInjured = 1;\r\n        window.requestAnimationFrame(function () { return _this.refreshScreen(); });\r\n    };\r\n    Game.prototype.die = function () {\r\n        // Reset score\r\n        this.score = 0;\r\n        // Reset keys\r\n        this.keys = [];\r\n        this.roomsOfFoundKeys = [];\r\n        // Reset keyholes\r\n        for (var _i = 0, _a = this.rooms; _i < _a.length; _i++) {\r\n            var room = _a[_i];\r\n            if (room.keyHoleColor != \"\" && room.wallCollisionRects[0].y != room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height) {\r\n                var oldY = room.wallCollisionRects[0].y;\r\n                room.wallCollisionRects[0].y = room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height;\r\n                room.wallCollisionRects[0].height = oldY - room.wallCollisionRects[0].y;\r\n            }\r\n        }\r\n        this.playerCollisionRect.x = 16;\r\n        this.playerCollisionRect.y = 176 / 2 - this.playerCollisionRect.height / 2;\r\n        this.setNewRoom(0);\r\n        this.playerLives = 4;\r\n    };\r\n    Game.prototype.createRoomBackground = function () {\r\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\r\n        //Top left\r\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\r\n            var canCreateBackground = true;\r\n            for (var _i = 0, _a = this.currentRoom.wallCollisionRects; _i < _a.length; _i++) {\r\n                var wall = _a[_i];\r\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 8 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\r\n                var canExtendBackground = true;\r\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n                    var wall = _c[_b];\r\n                    if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\r\n                        canExtendBackground = false;\r\n                        this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus - 8, height: 16 });\r\n                        break;\r\n                    }\r\n                }\r\n                if (!canExtendBackground) {\r\n                    break;\r\n                }\r\n                else if (widthBonus == 320 / 2 - 8) {\r\n                    this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 16 });\r\n                }\r\n            }\r\n            for (var _d = 0, _e = this.currentRoom.wallCollisionRects; _d < _e.length; _d++) {\r\n                var wall = _e[_d];\r\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 16 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n        }\r\n        // Bottom left\r\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\r\n            var canCreateBackground = true;\r\n            for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\r\n                var wall = _g[_f];\r\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\r\n                var canExtendBackground = true;\r\n                for (var _h = 0, _j = this.currentRoom.wallCollisionRects; _h < _j.length; _h++) {\r\n                    var wall = _j[_h];\r\n                    if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\r\n                        canExtendBackground = false;\r\n                        this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus - 8, height: 16 });\r\n                        break;\r\n                    }\r\n                }\r\n                if (!canExtendBackground) {\r\n                    break;\r\n                }\r\n                else if (widthBonus == 320 / 2 - 8) {\r\n                    this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\r\n                }\r\n            }\r\n            for (var _k = 0, _l = this.currentRoom.wallCollisionRects; _k < _l.length; _k++) {\r\n                var wall = _l[_k];\r\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n        }\r\n        // Top right\r\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\r\n            var canCreateBackground = true;\r\n            for (var _m = 0, _o = this.currentRoom.wallCollisionRects; _m < _o.length; _m++) {\r\n                var wall = _o[_m];\r\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 8 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\r\n                var canExtendBackground = true;\r\n                for (var _p = 0, _q = this.currentRoom.wallCollisionRects; _p < _q.length; _p++) {\r\n                    var wall = _q[_p];\r\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\r\n                        canExtendBackground = false;\r\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\r\n                        break;\r\n                    }\r\n                }\r\n                if (!canExtendBackground) {\r\n                    break;\r\n                }\r\n                else if (widthBonus == 320 / 2 - 8) {\r\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\r\n                }\r\n            }\r\n            for (var _r = 0, _s = this.currentRoom.wallCollisionRects; _r < _s.length; _r++) {\r\n                var wall = _s[_r];\r\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 16 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n        }\r\n        // Bottom right\r\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\r\n            var canCreateBackground = true;\r\n            for (var _t = 0, _u = this.currentRoom.wallCollisionRects; _t < _u.length; _t++) {\r\n                var wall = _u[_t];\r\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\r\n                var canExtendBackground = true;\r\n                for (var _v = 0, _w = this.currentRoom.wallCollisionRects; _v < _w.length; _v++) {\r\n                    var wall = _w[_v];\r\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\r\n                        canExtendBackground = false;\r\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\r\n                        break;\r\n                    }\r\n                }\r\n                if (!canExtendBackground) {\r\n                    break;\r\n                }\r\n                else if (widthBonus == 320 / 2 - 8) {\r\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\r\n                }\r\n            }\r\n            for (var _x = 0, _y = this.currentRoom.wallCollisionRects; _x < _y.length; _x++) {\r\n                var wall = _y[_x];\r\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\r\n                    canCreateBackground = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (!canCreateBackground) {\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    Game.prototype.placeShadow = function () {\r\n        var shadowMargin = 15;\r\n        var shadowPlacements = [\r\n            [shadowMargin, shadowMargin],\r\n            [320 - shadowMargin - this.shadowCollisionRect.width, shadowMargin],\r\n            [320 - shadowMargin - this.shadowCollisionRect.width, 176 - shadowMargin - this.shadowCollisionRect.height],\r\n            [shadowMargin, 176 - shadowMargin - this.shadowCollisionRect.height]\r\n        ];\r\n        var newShadowPlacement = shadowPlacements[Math.floor(Math.random() * shadowPlacements.length)];\r\n        this.shadowCollisionRect.x = newShadowPlacement[0];\r\n        this.shadowCollisionRect.y = newShadowPlacement[1];\r\n    };\r\n    Game.prototype.moveShadow = function () {\r\n        var playerCenterX = this.playerCollisionRect.x + this.playerCollisionRect.width / 2;\r\n        var playerCenterY = this.playerCollisionRect.y + this.playerCollisionRect.height / 2;\r\n        var shadowCenterX = this.shadowCollisionRect.x + this.shadowCollisionRect.width / 2;\r\n        var shadowCenterY = this.shadowCollisionRect.y + this.shadowCollisionRect.height / 2;\r\n        if (this.shadowSpeed <= Math.abs(playerCenterX - shadowCenterX)) {\r\n            this.shadowCollisionRect.x += (playerCenterX - shadowCenterX) / Math.abs(playerCenterX - shadowCenterX) * this.shadowSpeed;\r\n        }\r\n        else {\r\n            this.shadowCollisionRect.x += playerCenterX - shadowCenterX;\r\n        }\r\n        if (this.shadowSpeed <= Math.abs(playerCenterY - shadowCenterY)) {\r\n            this.shadowCollisionRect.y += (playerCenterY - shadowCenterY) / Math.abs(playerCenterY - shadowCenterY) * this.shadowSpeed;\r\n        }\r\n        else {\r\n            this.shadowCollisionRect.y += playerCenterY - shadowCenterY;\r\n        }\r\n    };\r\n    Game.prototype.createEnemies = function (n) {\r\n        var maxEnemyType = Math.floor(this.currentRoom.id / 10);\r\n        if (maxEnemyType > 2)\r\n            maxEnemyType = 2;\r\n        var i = 0;\r\n        while (i < n) {\r\n            var newEnemy = new _Enemy__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Math.floor(Math.random() * (maxEnemyType + 1)));\r\n            newEnemy.setPosition(Math.floor(Math.random() * (320 - newEnemy.collisionRect.width)), Math.floor(Math.random() * (176 - newEnemy.collisionRect.height)));\r\n            var isAbleToAddEnemy = true;\r\n            for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\r\n                var backgroundLine = _a[_i];\r\n                if (this.isCollisionDetected(newEnemy.collisionRect, backgroundLine)) {\r\n                    isAbleToAddEnemy = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isAbleToAddEnemy) {\r\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n                    var wall = _c[_b];\r\n                    if (this.isCollisionDetected(newEnemy.collisionRect, wall)) {\r\n                        isAbleToAddEnemy = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (isAbleToAddEnemy) {\r\n                for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\r\n                    var enemy = _e[_d];\r\n                    if (this.isCollisionDetected(newEnemy.collisionRect, enemy.collisionRect)) {\r\n                        isAbleToAddEnemy = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (isAbleToAddEnemy) {\r\n                this.enemies.push(newEnemy);\r\n                i++;\r\n            }\r\n        }\r\n    };\r\n    Game.prototype.placeKey = function () {\r\n        if (this.currentRoom.keyColor != \"\") {\r\n            var isAbleToPlaceKey = void 0;\r\n            do {\r\n                isAbleToPlaceKey = true;\r\n                this.keyCollisionRect = { x: Math.floor(Math.random() * (320 - 14)), y: Math.floor(Math.random() * (176 - 6)), width: 14, height: 6 };\r\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\r\n                    var backgroundLine = _a[_i];\r\n                    if (this.isCollisionDetected(this.keyCollisionRect, backgroundLine)) {\r\n                        isAbleToPlaceKey = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (isAbleToPlaceKey) {\r\n                    for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n                        var wall = _c[_b];\r\n                        if (this.isCollisionDetected(this.keyCollisionRect, wall)) {\r\n                            isAbleToPlaceKey = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } while (!isAbleToPlaceKey);\r\n        }\r\n    };\r\n    Game.prototype.placeKeyHole = function () {\r\n        if (this.currentRoom.keyHoleColor != \"\") {\r\n            var isAbleToPlaceKeyHole = void 0;\r\n            do {\r\n                isAbleToPlaceKeyHole = true;\r\n                var keyHoleX = Math.floor(320 * Math.floor(Math.random() * 5) / 5 + 320 / 10 - 16 / 2);\r\n                var keyHoleY = Math.floor(176 * Math.floor(Math.random() * 3) / 3 + 176 / 6 - 13 / 2);\r\n                this.keyHoleCollisionRect = { x: keyHoleX, y: keyHoleY, width: 16, height: 13 };\r\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\r\n                    var backgroundLine = _a[_i];\r\n                    if (this.isCollisionDetected(this.keyHoleCollisionRect, backgroundLine)) {\r\n                        isAbleToPlaceKeyHole = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } while (!isAbleToPlaceKeyHole);\r\n        }\r\n    };\r\n    Game.prototype.playerDetectAction = function (e) {\r\n        var _this = this;\r\n        var key = e.key;\r\n        if (key == \"Control\") {\r\n            var movementforceX = 0;\r\n            var movementforceY = 0;\r\n            if (this.playerMovementsObject.goRight) {\r\n                movementforceX = 1;\r\n            }\r\n            else if (this.playerMovementsObject.goLeft) {\r\n                movementforceX = -1;\r\n            }\r\n            clearInterval(this.playerMovementsObject.goLeft);\r\n            this.playerMovementsObject.goLeft = null;\r\n            clearInterval(this.playerMovementsObject.goRight);\r\n            this.playerMovementsObject.goRight = null;\r\n            if (this.playerMovementsObject.goUp) {\r\n                movementforceY = -1;\r\n            }\r\n            else if (this.playerMovementsObject.goDown) {\r\n                movementforceY = 1;\r\n            }\r\n            clearInterval(this.playerMovementsObject.goDown);\r\n            this.playerMovementsObject.goDown = null;\r\n            clearInterval(this.playerMovementsObject.goUp);\r\n            this.playerMovementsObject.goUp = null;\r\n            this.isFireModeOn = true;\r\n            if ((movementforceX != 0 || movementforceY != 0) && this.isGunLoaded && this.playerBullets.length < 2) {\r\n                this.firePlayerBullet([movementforceX, movementforceY]);\r\n            }\r\n        }\r\n        else if (this.isFireModeOn && this.isGunLoaded) {\r\n            if (this.playerBullets.length < 2) {\r\n                switch (key) {\r\n                    case \"ArrowRight\":\r\n                        this.firePlayerBullet([1, 0]);\r\n                        break;\r\n                    case \"ArrowLeft\":\r\n                        this.firePlayerBullet([-1, 0]);\r\n                        break;\r\n                    case \"ArrowUp\":\r\n                        this.firePlayerBullet([0, -1]);\r\n                        break;\r\n                    case \"ArrowDown\":\r\n                        this.firePlayerBullet([0, 1]);\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        else if (key == \"ArrowDown\" && !this.playerMovementsObject.goDown) {\r\n            this.playerMovementsObject.goDown = setInterval(function () {\r\n                if (_this.playerCollisionRect.y <= 1080 - _this.playerCollisionRect.height - _this.playerSpeed) {\r\n                    _this.playerCollisionRect.y += _this.playerSpeed;\r\n                }\r\n            }, Math.floor(1000 / 60));\r\n        }\r\n        else if (key == \"ArrowUp\" && !this.playerMovementsObject.goUp) {\r\n            this.playerMovementsObject.goUp = setInterval(function () {\r\n                if (_this.playerCollisionRect.y >= 0) {\r\n                    _this.playerCollisionRect.y -= _this.playerSpeed;\r\n                }\r\n            }, Math.floor(1000 / 60));\r\n        }\r\n        else if (key == \"ArrowRight\" && !this.playerMovementsObject.goRight) {\r\n            this.playerMovementsObject.goRight = setInterval(function () {\r\n                if (_this.playerCollisionRect.x <= 1920 - _this.playerCollisionRect.width - _this.playerSpeed) {\r\n                    _this.playerCollisionRect.x += _this.playerSpeed;\r\n                }\r\n            }, Math.floor(1000 / 60));\r\n        }\r\n        else if (key == \"ArrowLeft\" && !this.playerMovementsObject.goLeft) {\r\n            this.playerMovementsObject.goLeft = setInterval(function () {\r\n                if (_this.playerCollisionRect.x >= 0) {\r\n                    _this.playerCollisionRect.x -= _this.playerSpeed;\r\n                }\r\n            }, Math.floor(1000 / 60));\r\n        }\r\n    };\r\n    Game.prototype.playerStopAction = function (e) {\r\n        var key = e.key;\r\n        if (key == \"Control\") {\r\n            this.isFireModeOn = false;\r\n        }\r\n        else if (key == \"ArrowDown\") {\r\n            this.isGunLoaded = true;\r\n            clearInterval(this.playerMovementsObject.goDown);\r\n            this.playerMovementsObject.goDown = null;\r\n        }\r\n        else if (key == \"ArrowUp\") {\r\n            this.isGunLoaded = true;\r\n            clearInterval(this.playerMovementsObject.goUp);\r\n            this.playerMovementsObject.goUp = null;\r\n        }\r\n        else if (key == \"ArrowRight\") {\r\n            this.isGunLoaded = true;\r\n            clearInterval(this.playerMovementsObject.goRight);\r\n            this.playerMovementsObject.goRight = null;\r\n        }\r\n        else if (key == \"ArrowLeft\") {\r\n            this.isGunLoaded = true;\r\n            clearInterval(this.playerMovementsObject.goLeft);\r\n            this.playerMovementsObject.goLeft = null;\r\n        }\r\n    };\r\n    Game.prototype.firePlayerBullet = function (movementForces) {\r\n        this.isGunLoaded = false;\r\n        var newBullet = new _Bullet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.bulletsFired, movementForces);\r\n        var horizontalCenterDistance = (this.playerCollisionRect.width / 2 + newBullet.width / 2);\r\n        var verticalCenterDistance = (this.playerCollisionRect.height / 2 + newBullet.height / 2);\r\n        var newBulletX = Math.floor(this.playerCollisionRect.x + this.playerCollisionRect.width / 2 + horizontalCenterDistance * movementForces[0] - newBullet.width / 2);\r\n        var newBulletY = Math.floor(this.playerCollisionRect.y + this.playerCollisionRect.height / 2 + verticalCenterDistance * movementForces[1] - newBullet.height / 2);\r\n        newBullet.setCoords(newBulletX, newBulletY);\r\n        this.playerBullets.push(newBullet);\r\n        this.bulletsFired += 1;\r\n    };\r\n    Game.prototype.moveEnemies = function () {\r\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\r\n            var enemy = _a[_i];\r\n            if (enemy.type == 2) {\r\n                if (this.frame % 2 == 0) {\r\n                    var distanceX = (this.playerCollisionRect.x + this.playerCollisionRect.width / 2) - (enemy.collisionRect.x + enemy.collisionRect.width / 2);\r\n                    var distanceY = (this.playerCollisionRect.y + this.playerCollisionRect.height / 2) - (enemy.collisionRect.y + enemy.collisionRect.height / 2);\r\n                    if (Math.abs(distanceX) > enemy.speed) {\r\n                        distanceX = distanceX / Math.abs(distanceX) * enemy.speed;\r\n                    }\r\n                    if (Math.abs(distanceY) > enemy.speed) {\r\n                        distanceY = distanceY / Math.abs(distanceY) * enemy.speed;\r\n                    }\r\n                    var newCollisionRect = { x: enemy.collisionRect.x + distanceX, y: enemy.collisionRect.y + distanceY, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\r\n                    while (!this.canEnemyMove(enemy, newCollisionRect)) {\r\n                        if (Math.abs(distanceX) >= Math.abs(distanceY)) {\r\n                            distanceY = 0;\r\n                        }\r\n                        else {\r\n                            distanceX = 0;\r\n                        }\r\n                        newCollisionRect = { x: enemy.collisionRect.x + distanceX, y: enemy.collisionRect.y + distanceY, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\r\n                    }\r\n                    enemy.collisionRect = newCollisionRect;\r\n                }\r\n            }\r\n            else if (enemy.type == 1) {\r\n                if (this.frame - enemy.movementObject.endFrame >= 8) {\r\n                    // Start new movement\r\n                    if (this.canEnemySeePlayer(enemy)) {\r\n                        // Choose direction\r\n                        // console.log('real move')\r\n                        var distanceX = (this.playerCollisionRect.x + this.playerCollisionRect.width / 2) - (enemy.collisionRect.x + enemy.collisionRect.width / 2);\r\n                        var distanceY = (this.playerCollisionRect.y + this.playerCollisionRect.height / 2) - (enemy.collisionRect.y + enemy.collisionRect.height / 2);\r\n                        if (Math.abs(distanceX) > Math.abs(distanceY)) {\r\n                            enemy.movementObject.forceX = distanceX / Math.abs(distanceX);\r\n                        }\r\n                        else {\r\n                            enemy.movementObject.forceY = distanceY / Math.abs(distanceY);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Random direction\r\n                        // console.log('random move')\r\n                        var randOfFour = Math.floor(Math.random() * 4);\r\n                        if (randOfFour % 2 == 0) {\r\n                            enemy.movementObject.forceX = randOfFour - 1;\r\n                        }\r\n                        else {\r\n                            enemy.movementObject.forceY = randOfFour - 2;\r\n                        }\r\n                    }\r\n                    enemy.movementObject.endFrame = this.frame + 48 / enemy.speed;\r\n                }\r\n                else if (this.frame == enemy.movementObject.endFrame) {\r\n                    // Reset movement forces\r\n                    enemy.movementObject.forceX = 0;\r\n                    enemy.movementObject.forceY = 0;\r\n                }\r\n                else if (this.frame < enemy.movementObject.endFrame) {\r\n                    // Move if possible\r\n                    var newCollisionRect = { x: enemy.collisionRect.x + enemy.movementObject.forceX * enemy.speed, y: enemy.collisionRect.y + enemy.movementObject.forceY * enemy.speed, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\r\n                    if (this.canEnemyMove(enemy, newCollisionRect)) {\r\n                        enemy.collisionRect = newCollisionRect;\r\n                    }\r\n                    else {\r\n                        // Stop movement\r\n                        enemy.movementObject.forceX = 0;\r\n                        enemy.movementObject.forceY = 0;\r\n                        enemy.movementObject.endFrame = this.frame;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Horizontal\r\n                var horizontalDistance = this.playerCollisionRect.x - enemy.collisionRect.x;\r\n                for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x); i += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed) {\r\n                    var didHitWall = false;\r\n                    for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n                        var wall = _c[_b];\r\n                        if (this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\r\n                            didHitWall = true;\r\n                            horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!didHitWall) {\r\n                        for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\r\n                            var encounteredEnemmy = _e[_d];\r\n                            if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\r\n                                didHitWall = true;\r\n                                horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (didHitWall) {\r\n                        break;\r\n                    }\r\n                }\r\n                // Vertical\r\n                var verticalDistance = this.playerCollisionRect.y - enemy.collisionRect.y;\r\n                for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y); i += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed) {\r\n                    var didHitWall = false;\r\n                    for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\r\n                        var wall = _g[_f];\r\n                        if (this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\r\n                            didHitWall = true;\r\n                            verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!didHitWall) {\r\n                        for (var _h = 0, _j = this.enemies; _h < _j.length; _h++) {\r\n                            var encounteredEnemmy = _j[_h];\r\n                            if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\r\n                                didHitWall = true;\r\n                                verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (didHitWall) {\r\n                        break;\r\n                    }\r\n                }\r\n                if (Math.abs(horizontalDistance) > Math.abs(verticalDistance) && Math.abs(horizontalDistance) >= enemy.speed) {\r\n                    // if(Math.abs(horizontalDistance) >= enemy.speed)\r\n                    enemy.collisionRect.x += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\r\n                    // else\r\n                    //     enemy.collisionRect.x += Math.floor(horizontalDistance)\r\n                }\r\n                else if (Math.abs(verticalDistance) >= enemy.speed) {\r\n                    // if(Math.abs(verticalDistance) >= enemy.speed)\r\n                    enemy.collisionRect.y += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\r\n                    // else\r\n                    //     enemy.collisionRect.y += Math.floor(verticalDistance)\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Game.prototype.fireEnemyBullets = function () {\r\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\r\n            var enemy = _a[_i];\r\n            if (enemy.type != 2 && this.roomsTraveledSinceInjured >= 3) {\r\n                var bulletDirections = this.canEnemyShootPlayer(enemy);\r\n                if (bulletDirections) {\r\n                    var newEnemyBullet = new _EnemyBullet__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.bulletsFired, bulletDirections.x, bulletDirections.y, bulletDirections.movementForceX, bulletDirections.movementForceY);\r\n                    this.enemyBullets.push(newEnemyBullet);\r\n                    // console.log(newEnemyBullet)\r\n                    this.bulletsFired += 1;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Game.prototype.isNumberBetween = function (n, min, max) {\r\n        return n >= min && n <= max;\r\n    };\r\n    Game.prototype.isCollisionDetected = function (cr1, cr2) {\r\n        if (cr1.x + cr1.width > cr2.x\r\n            && cr1.x < cr2.x + cr2.width\r\n            && cr1.y + cr1.height > cr2.y\r\n            && cr1.y < cr2.y + cr2.height) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    Game.prototype.canEnemyMove = function (enemy, newCollisionRect) {\r\n        if (newCollisionRect.x < 0 || newCollisionRect.y < 0 || newCollisionRect.x + newCollisionRect.width > 320 || newCollisionRect.y + newCollisionRect.height > 176) {\r\n            return false;\r\n        }\r\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\r\n            var otherEnemy = _a[_i];\r\n            if (!otherEnemy.equals(enemy) && this.isCollisionDetected(otherEnemy.collisionRect, newCollisionRect)) {\r\n                return false;\r\n            }\r\n        }\r\n        for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\r\n            var wall = _c[_b];\r\n            if (this.isCollisionDetected(newCollisionRect, wall)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    Game.prototype.canEnemySeePlayer = function (enemy) {\r\n        var enemyPoint = [enemy.collisionRect.x + enemy.collisionRect.width / 2, enemy.collisionRect.y + enemy.collisionRect.height / 2];\r\n        var playerPoint = [this.playerCollisionRect.x + this.playerCollisionRect.width / 2, this.playerCollisionRect.y + this.playerCollisionRect.height / 2];\r\n        var wallPoint1, wallPoint2;\r\n        for (var _i = 0, _a = this.currentRoom.wallCollisionRects; _i < _a.length; _i++) {\r\n            var wall = _a[_i];\r\n            wallPoint1 = [wall.x, wall.y];\r\n            wallPoint2 = [wall.x + wall.width, wall.y + wall.height];\r\n            if (this.isIntersectionDetected(enemyPoint, playerPoint, wallPoint1, wallPoint2))\r\n                return false;\r\n        }\r\n        return true;\r\n    };\r\n    Game.prototype.canEnemyShootPlayer = function (enemy) {\r\n        var forceX = 0;\r\n        var forceY = 0;\r\n        var enemyCenterX = Math.round(enemy.collisionRect.x + enemy.collisionRect.width / 2);\r\n        var enemyCenterY = Math.round(enemy.collisionRect.y + enemy.collisionRect.height / 2);\r\n        if (!this.canEnemySeePlayer(enemy))\r\n            return false;\r\n        var playerPointX;\r\n        var playerPointY;\r\n        if (this.frame % 4 == 0 && enemyCenterX >= this.playerCollisionRect.x && enemyCenterX <= this.playerCollisionRect.x + this.playerCollisionRect.width) {\r\n            playerPointX = enemyCenterX;\r\n            playerPointY = Math.round(this.playerCollisionRect.y + this.playerCollisionRect.height / 2);\r\n        }\r\n        else if (this.frame % 4 == 0 && enemyCenterY >= this.playerCollisionRect.y && enemyCenterY <= this.playerCollisionRect.y + this.playerCollisionRect.height / 2) {\r\n            playerPointY = enemyCenterY;\r\n            playerPointX = Math.round(this.playerCollisionRect.x + this.playerCollisionRect.width / 2);\r\n        }\r\n        else if (this.frame % 2 == 0 && enemyCenterX - enemyCenterY >= this.playerCollisionRect.x - (this.playerCollisionRect.y + this.playerCollisionRect.height)\r\n            && enemyCenterX - enemyCenterY <= (this.playerCollisionRect.x + this.playerCollisionRect.width) - this.playerCollisionRect.y) {\r\n            var xCandidate = this.playerCollisionRect.x;\r\n            var yCandidate = this.playerCollisionRect.y + this.playerCollisionRect.height;\r\n            while (xCandidate - yCandidate != enemyCenterX - enemyCenterY) {\r\n                if (xCandidate > this.playerCollisionRect.x + this.playerCollisionRect.width) {\r\n                    xCandidate = this.playerCollisionRect.x + this.playerCollisionRect.width;\r\n                    yCandidate = this.playerCollisionRect.y;\r\n                    while (xCandidate - yCandidate != enemyCenterX - enemyCenterY) {\r\n                        if (xCandidate < this.playerCollisionRect.x)\r\n                            return false;\r\n                        xCandidate -= 1;\r\n                        yCandidate += 1;\r\n                    }\r\n                    break;\r\n                }\r\n                xCandidate += 1;\r\n                yCandidate -= 1;\r\n            }\r\n            playerPointX = xCandidate;\r\n            playerPointY = yCandidate;\r\n        }\r\n        else if (this.frame % 2 == 0 && (320 - enemyCenterX) - enemyCenterY <= (320 - this.playerCollisionRect.x) - this.playerCollisionRect.y\r\n            && (320 - enemyCenterX) - enemyCenterY >= (320 - (this.playerCollisionRect.x + this.playerCollisionRect.width)) - (this.playerCollisionRect.y + this.playerCollisionRect.height)) {\r\n            var xCandidate = this.playerCollisionRect.x;\r\n            var yCandidate = this.playerCollisionRect.y;\r\n            while ((320 - xCandidate) - yCandidate != (320 - enemyCenterX) - enemyCenterY) {\r\n                if (xCandidate > this.playerCollisionRect.x + this.playerCollisionRect.width) {\r\n                    xCandidate = this.playerCollisionRect.x + this.playerCollisionRect.width;\r\n                    yCandidate = this.playerCollisionRect.y + this.playerCollisionRect.height;\r\n                    while ((320 - xCandidate) - yCandidate != (320 - enemyCenterX) - enemyCenterY) {\r\n                        if (xCandidate < this.playerCollisionRect.x)\r\n                            return false;\r\n                        xCandidate -= 1;\r\n                        yCandidate -= 1;\r\n                    }\r\n                    break;\r\n                }\r\n                xCandidate += 1;\r\n                yCandidate += 1;\r\n            }\r\n            playerPointX = xCandidate;\r\n            playerPointY = yCandidate;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n        if (playerPointX - enemyCenterX == 0)\r\n            forceX = 0;\r\n        else\r\n            forceX = (playerPointX - enemyCenterX) / Math.abs(playerPointX - enemyCenterX);\r\n        if (playerPointY - enemyCenterY == 0)\r\n            forceY = 0;\r\n        else\r\n            forceY = (playerPointY - enemyCenterY) / Math.abs(playerPointY - enemyCenterY);\r\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\r\n            var otherEnemy = _a[_i];\r\n            if (!otherEnemy.equals(enemy)) {\r\n                var otherEnemyPoint1 = [otherEnemy.collisionRect.x, otherEnemy.collisionRect.y];\r\n                var otherEnemyPoint2 = [otherEnemy.collisionRect.x + otherEnemy.collisionRect.width, otherEnemy.collisionRect.y + otherEnemy.collisionRect.height];\r\n                if (this.isIntersectionDetected([enemyCenterX, enemyCenterY], [playerPointX, playerPointY], otherEnemyPoint1, otherEnemyPoint2))\r\n                    return false;\r\n                otherEnemyPoint1 = [otherEnemy.collisionRect.x, otherEnemy.collisionRect.y + otherEnemy.collisionRect.height];\r\n                otherEnemyPoint2 = [otherEnemy.collisionRect.x + otherEnemy.collisionRect.width, otherEnemy.collisionRect.y];\r\n                if (this.isIntersectionDetected([enemyCenterX, enemyCenterY], [playerPointX, playerPointY], otherEnemyPoint1, otherEnemyPoint2))\r\n                    return false;\r\n            }\r\n        }\r\n        var horizontalCenterDistance = (enemy.collisionRect.width / 2 + 2 / 2);\r\n        var verticalCenterDistance = (enemy.collisionRect.height / 2 + 2 / 2);\r\n        var newBulletX = Math.floor(enemy.collisionRect.x + enemy.collisionRect.width / 2 + horizontalCenterDistance * forceX - 2 / 2);\r\n        var newBulletY = Math.floor(enemy.collisionRect.y + enemy.collisionRect.height / 2 + verticalCenterDistance * forceY - 2 / 2);\r\n        return { x: newBulletX, y: newBulletY, movementForceX: forceX, movementForceY: forceY };\r\n    };\r\n    Game.prototype.isIntersectionDetected = function (A, B, C, D) {\r\n        var v1 = this.vectorProduct(C, D, A);\r\n        var v2 = this.vectorProduct(C, D, B);\r\n        var v3 = this.vectorProduct(A, B, C);\r\n        var v4 = this.vectorProduct(A, B, D);\r\n        if ((v1 > 0 && v2 < 0 || v1 < 0 && v2 > 0) && (v3 > 0 && v4 < 0 || v3 < 0 && v4 > 0))\r\n            return true;\r\n        return false;\r\n    };\r\n    Game.prototype.vectorProduct = function (X, Y, Z) {\r\n        var x1 = Z[0] - X[0];\r\n        var y1 = Z[1] - X[1];\r\n        var x2 = Y[0] - X[0];\r\n        var y2 = Y[1] - X[1];\r\n        return x1 * y2 - x2 * y1;\r\n    };\r\n    Game.prototype.enemyArrayIncludes = function (enemyArray, enemyToCheck) {\r\n        for (var _i = 0, enemyArray_1 = enemyArray; _i < enemyArray_1.length; _i++) {\r\n            var enemy = enemyArray_1[_i];\r\n            if (enemyToCheck.equals(enemy))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    Game.prototype.bulletArrayIncludes = function (bulletArray, bulletToCheck) {\r\n        for (var _i = 0, bulletArray_1 = bulletArray; _i < bulletArray_1.length; _i++) {\r\n            var bullet = bulletArray_1[_i];\r\n            if (bulletToCheck.id == bullet.id)\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    Game.prototype.canReallyAnimate = function () {\r\n        return this.animationFrame % 6 == 0;\r\n    };\r\n    return Game;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Game);\r\n\n\n//# sourceURL=webpack://shamus/./src/Game.ts?");

/***/ }),

/***/ "./src/Room.ts":
/*!*********************!*\
  !*** ./src/Room.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Room = /** @class */ (function () {\r\n    function Room(id, levelColor, bgColor, wallCollisionRects, neighbourRoomsIds, keyColor, keyHoleColor) {\r\n        this.id = id;\r\n        this.levelColor = levelColor;\r\n        this.bgColor = bgColor;\r\n        this.wallCollisionRects = wallCollisionRects;\r\n        this.neighbourRoomsIds = neighbourRoomsIds;\r\n        this.keyColor = keyColor;\r\n        this.keyHoleColor = keyHoleColor;\r\n    }\r\n    return Room;\r\n}());\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Room);\r\n\n\n//# sourceURL=webpack://shamus/./src/Room.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\n\r\nvar newGame = new _Game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\n\n\n//# sourceURL=webpack://shamus/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;