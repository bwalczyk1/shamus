/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Bullet.ts":
/*!***********************!*\
  !*** ./src/Bullet.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Bullet = /** @class */ (function () {\n    function Bullet(id, movementForces) {\n        this.speed = 9;\n        this.id = id;\n        if (movementForces[0] == 0) {\n            this.type = \"vertical\";\n        }\n        else if (movementForces[1] == 0) {\n            this.type = \"horizontal\";\n        }\n        else if (movementForces[0] == movementForces[1]) {\n            this.type = \"diagonal\";\n        }\n        else {\n            this.type = \"diagonalInverted\";\n        }\n        this.speedX = movementForces[0] * this.speed;\n        this.speedY = movementForces[1] * this.speed;\n        if (this.type == \"horizontal\") {\n            this.width = 8;\n            this.height = 3;\n        }\n        else if (this.type == \"vertical\") {\n            this.width = 4;\n            this.height = 6;\n        }\n        else if (this.type == \"diagonal\" || this.type == \"diagonalInverted\") {\n            this.width = 4;\n            this.height = 4;\n        }\n    }\n    Bullet.prototype.setCoords = function (x, y) {\n        this.collisionRect = { x: x - this.speedX, y: y - this.speedY, width: this.width, height: this.height };\n    };\n    Bullet.prototype.move = function () {\n        this.collisionRect.x += this.speedX;\n        this.collisionRect.y += this.speedY;\n    };\n    return Bullet;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Bullet);\n\n\n//# sourceURL=webpack://shamus/./src/Bullet.ts?");

/***/ }),

/***/ "./src/Enemy.ts":
/*!**********************!*\
  !*** ./src/Enemy.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Enemy = /** @class */ (function () {\n    function Enemy(color) {\n        this.collisionRect = { x: 0, y: 0, width: 16, height: 8 };\n        this.moveInterval = null;\n        this.color = \"red\";\n        this.speed = 3;\n        this.color = color;\n    }\n    Enemy.prototype.setPosition = function (x, y) {\n        this.collisionRect.x = x;\n        this.collisionRect.y = y;\n    };\n    Enemy.prototype.equals = function (enemy) {\n        if (this.collisionRect.x == enemy.collisionRect.x && this.collisionRect.y == enemy.collisionRect.y) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return Enemy;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Enemy);\n\n\n//# sourceURL=webpack://shamus/./src/Enemy.ts?");

/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Bullet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bullet */ \"./src/Bullet.ts\");\n/* harmony import */ var _Enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enemy */ \"./src/Enemy.ts\");\n/* harmony import */ var _Room__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Room */ \"./src/Room.ts\");\n\n\n\nvar Game = /** @class */ (function () {\n    function Game() {\n        var _this = this;\n        this.frame = 0;\n        this.frameLength = 100;\n        this.rooms = [];\n        this.playerCollisionRect = { x: 0, y: 0, width: 14, height: 17 };\n        this.shadowCollisionRect = { x: 0, y: 0, width: 18, height: 15 };\n        this.basicSpeed = 5;\n        this.playerSpeed = this.basicSpeed;\n        this.shadowSpeed = 7;\n        this.shadowFreezeTime = 0;\n        this.playerMovementsObject = {};\n        this.enemies = [];\n        this.lastStartPosition = [16, Math.floor(176 / 2 - this.playerCollisionRect.height / 2)];\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\n        this.isFireModeOn = false;\n        this.isGunLoaded = true;\n        this.playerBullets = [];\n        this.playerLives = 4;\n        this.score = 0;\n        this.highScore = 0;\n        this.bulletsFired = 0;\n        this.roomsTraveledSinceInjured = 0;\n        this.keys = [];\n        this.roomsOfFoundKeys = [];\n        this.startTime = Date.now();\n        this.gameScreen = document.getElementById(\"gameScreen\");\n        // this.gameScreen.style.width = document.body.style.width;\n        // this.gameScreen.style.height = document.body.style.height;\n        this.ctx = this.gameScreen.getContext('2d');\n        // console.log(this.ctx)\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0, \"black\", \"yellow\", [\n            { x: 0, y: 64, width: 8, height: 48 },\n            { x: 0, y: 56, width: 56, height: 8 },\n            { x: 48, y: 8, width: 8, height: 48 },\n            { x: 48, y: 0, width: 224, height: 8 },\n            { x: 264, y: 8, width: 8, height: 48 },\n            { x: 264, y: 56, width: 56, height: 8 },\n            { x: 264, y: 112, width: 56, height: 8 },\n            { x: 264, y: 120, width: 8, height: 48 },\n            { x: 48, y: 168, width: 224, height: 8 },\n            { x: 48, y: 120, width: 8, height: 48 },\n            { x: 0, y: 112, width: 128, height: 8 },\n            { x: 120, y: 56, width: 8, height: 56 },\n            { x: 128, y: 56, width: 64, height: 8 },\n            { x: 192, y: 56, width: 8, height: 56 }\n        ], [null, 1, null, null], \"blue\", \"\"));\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1, \"black\", \"yellow\", [\n            { x: 320 - 8, y: 56 + 8, width: 8, height: 112 - 56 - 8 },\n            { x: 0, y: 112, width: 320, height: 8 },\n            { x: 0, y: 56, width: 320, height: 8 }\n        ], [null, null, null, 0], \"\", \"blue\"));\n        this.playerCollisionRect.x = this.lastStartPosition[0];\n        this.playerCollisionRect.y = this.lastStartPosition[1];\n        this.setNewRoom(0);\n        document.addEventListener(\"keydown\", function (event) { _this.playerDetectAction(event); });\n        document.addEventListener(\"keyup\", function (event) { _this.playerStopAction(event); });\n        setInterval(function () { _this.refreshScreen(); }, this.frameLength);\n        // requestAnimationFrame(()=>{this.refreshScreen()})\n    }\n    Game.prototype.refreshScreen = function () {\n        var _this = this;\n        console.log(this.playerCollisionRect.x);\n        this.ctx = this.gameScreen.getContext('2d');\n        this.ctx.imageSmoothingEnabled = false;\n        this.ctx.clearRect(0, 0, 320, 208);\n        // this.ctx.fillStyle = \"black\"\n        // this.ctx.fillRect(0, 0, 320, 208)\n        //Detect room change\n        if (this.playerCollisionRect.y < 0) {\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[0]);\n        }\n        else if (this.playerCollisionRect.x + this.playerCollisionRect.width > 320) {\n            this.playerCollisionRect.x = 16;\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[1]);\n        }\n        else if (this.playerCollisionRect.y + this.playerCollisionRect.height > 176) {\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[2]);\n        }\n        else if (this.playerCollisionRect.x < 0) {\n            this.playerCollisionRect.x = 320 - 16 - this.playerCollisionRect.width;\n            this.setNewRoom(this.currentRoom.neighbourRoomsIds[3]);\n        }\n        // Draw shadow and detect collision with player\n        if (Date.now() - this.timeOfEnteringRoom >= 15000) {\n            var isShadowFrozen = (Date.now() - this.shadowFreezeTime <= 2500);\n            var isShadowInMmove = Date.now() - this.timeOfEnteringRoom >= 17500;\n            if (isShadowInMmove && !isShadowFrozen) {\n                var newX = void 0, newY = void 0;\n                if (this.frame % 2 == 1) {\n                    newX = this.shadowCollisionRect.x - 2;\n                    newY = this.shadowCollisionRect.y + 2;\n                    this.shadowCollisionRect = { x: newX, y: newY, width: 22, height: 11 };\n                }\n                else {\n                    newX = this.shadowCollisionRect.x + 2;\n                    newY = this.shadowCollisionRect.y - 2;\n                    this.shadowCollisionRect = { x: newX, y: newY, width: 18, height: 15 };\n                }\n                this.moveShadow();\n            }\n            // console.log(this.shadowCollisionRect)\n            var shadowImg = document.createElement('img');\n            if (isShadowFrozen) {\n                shadowImg.src = './assets/enemies/shadow/frozen' + this.shadowFreezeTime % 2 + '.png';\n            }\n            else if (isShadowInMmove) {\n                shadowImg.src = './assets/enemies/shadow/' + this.frame % 2 + '.png';\n            }\n            else {\n                shadowImg.src = './assets/enemies/shadow/0.png';\n            }\n            this.ctx.drawImage(shadowImg, this.shadowCollisionRect.x, this.shadowCollisionRect.y);\n            if (this.isCollisionDetected(this.shadowCollisionRect, this.playerCollisionRect)) {\n                this.takeDamage();\n                return;\n            }\n        }\n        // Draw background\n        var wallImg = document.createElement('img');\n        wallImg.src = './assets/background/' + this.currentRoom.bgColor + '.png';\n        for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n            var backgroundLine = _a[_i];\n            for (var i = 0; i < backgroundLine.width; i += 8) {\n                this.ctx.drawImage(wallImg, backgroundLine.x + i, backgroundLine.y);\n            }\n        }\n        // Draw walls and detect their collisions with player\n        for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n            var wall = _c[_b];\n            if (this.currentRoom.levelColor == \"black\") {\n                this.ctx.fillStyle = \"white\";\n            }\n            else {\n                this.ctx.fillStyle = this.currentRoom.levelColor;\n            }\n            if (this.isCollisionDetected(wall, this.playerCollisionRect)) {\n                this.takeDamage();\n                return;\n            }\n            this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);\n            this.ctx.fillStyle = \"blue\";\n            if (wall == this.currentRoom.wallCollisionRects[0]) {\n                var realFrame = this.frame - (wall.y - (this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height)) / 2;\n                for (var i = 0; i < wall.height; i += 8) {\n                    this.ctx.fillRect(wall.x, wall.y + i + realFrame % 4 * 2, wall.width, 2);\n                }\n            }\n            else if (wall.width >= wall.height) {\n                for (var i = 0; i < wall.width; i += 8) {\n                    this.ctx.fillRect(wall.x + i + this.frame % 4 * 2, wall.y, 2, wall.height);\n                }\n            }\n            else {\n                for (var i = 0; i < wall.height; i += 8) {\n                    this.ctx.fillRect(wall.x, wall.y + i + this.frame % 4 * 2, wall.width, 2);\n                }\n            }\n        }\n        // Draw interface\n        // Highscore\n        this.ctx.clearRect(0, 2 * 8, 6 * 8, 8);\n        var highScoreString = this.highScore.toString();\n        for (var i = 0; i < highScoreString.length; i++) {\n            var digitString = highScoreString[i];\n            var digitImg = document.createElement('img');\n            digitImg.src = './assets/highscoreDigits/' + digitString + '.png';\n            var digitX = 6 * 8 - (highScoreString.length - i) * 8;\n            this.ctx.drawImage(digitImg, digitX, 2 * 8);\n        }\n        // Score\n        this.ctx.clearRect(0, 4 * 8, 6 * 8, 8);\n        var scoreString = this.score.toString();\n        for (var i = 0; i < scoreString.length; i++) {\n            var digitString = scoreString[i];\n            var digitImg = document.createElement('img');\n            digitImg.src = './assets/digits/' + digitString + '.png';\n            var digitX = 6 * 8 - (scoreString.length - i) * 8;\n            this.ctx.drawImage(digitImg, digitX, 4 * 8);\n        }\n        // Lives\n        this.ctx.clearRect(320 - 6 * 8, 8, 6 * 8, 6 * 8);\n        var lifeImg = document.createElement('img');\n        lifeImg.src = './assets/playerLife.png';\n        for (var i = 1; i <= this.playerLives; i++) {\n            this.ctx.drawImage(lifeImg, 320 - 6 * 8 + (i - 1) % 3 * 16, 8 + Math.floor((i - 1) / 3) * 16);\n        }\n        // Room info and inventory\n        this.ctx.clearRect(0, 208 - 4 * 8, 320, 4 * 8);\n        // - Keys\n        if (this.keys.includes(\"blue\")) {\n            var blueKeyImage = document.createElement('img');\n            blueKeyImage.src = './assets/keys/blue.png';\n            this.ctx.drawImage(blueKeyImage, 7 * 16 + 1, 176 + 1);\n        }\n        // - Room info\n        var interfaceImage = document.createElement('img');\n        interfaceImage.src = './assets/interface.png';\n        this.ctx.drawImage(interfaceImage, 8 + 1, 176 + 8);\n        // - Room number\n        var roomString = this.currentRoom.id.toString();\n        for (var i = 0; i < roomString.length; i++) {\n            var digitString = roomString[i];\n            var digitImg = document.createElement('img');\n            digitImg.src = './assets/digits/' + digitString + '.png';\n            var digitX = (7 + i) * 8;\n            this.ctx.drawImage(digitImg, digitX, 176 + 8);\n        }\n        // Draw player\n        // this.ctx.fillStyle = \"white\"\n        // this.ctx.fillRect(this.playerCollisionRect.x, this.playerCollisionRect.y, this.playerCollisionRect.width, this.playerCollisionRect.height)\n        var playerImg = document.createElement('img');\n        if (this.playerMovementsObject.goRight) {\n            playerImg.src = './assets/player/right/' + (this.frame % 2) + '.png';\n        }\n        else if (this.playerMovementsObject.goLeft) {\n            playerImg.src = './assets/player/left/' + (this.frame % 2) + '.png';\n        }\n        else if (this.playerMovementsObject.goUp || this.playerMovementsObject.goDown) {\n            playerImg.src = './assets/player/vert/' + (this.frame % 2) + '.png';\n        }\n        else {\n            playerImg.src = './assets/player/still.png';\n        }\n        this.ctx.drawImage(playerImg, this.playerCollisionRect.x, this.playerCollisionRect.y);\n        // Move enemies\n        this.moveEnemies();\n        // Draw enemies and detect their collisions with player\n        for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\n            var enemy = _e[_d];\n            if (this.isCollisionDetected(this.playerCollisionRect, enemy.collisionRect)) {\n                this.takeDamage();\n                return;\n            }\n            else {\n                // this.ctx.fillStyle = enemy.color\n                // this.ctx.fillRect(enemy.collisionRect.x, enemy.collisionRect.y, enemy.collisionRect.width, enemy.collisionRect.height)\n                var enemyPhase = this.frame % 4;\n                var enemyImg = document.createElement('img');\n                enemyImg.src = './assets/enemies/drone/' + enemy.color + '/' + enemyPhase + '.png';\n                this.ctx.drawImage(enemyImg, enemy.collisionRect.x, enemy.collisionRect.y);\n            }\n        }\n        // Move and draw bullets\n        for (var _f = 0, _g = this.playerBullets; _f < _g.length; _f++) {\n            var bullet = _g[_f];\n            bullet.move();\n            var bulletImg = document.createElement('img');\n            bulletImg.src = './assets/bullets/' + bullet.type + '.png';\n            if (bullet.type == \"diagonal\" || bullet.type == \"diagonalInverted\") {\n                this.ctx.drawImage(bulletImg, bullet.collisionRect.x - 1, bullet.collisionRect.y - 1);\n            }\n            else {\n                this.ctx.drawImage(bulletImg, bullet.collisionRect.x, bullet.collisionRect.y);\n            }\n        }\n        // Draw key and detect its collision with player\n        if (this.currentRoom.keyColor != \"\" && !this.roomsOfFoundKeys.includes(this.currentRoom.id)) {\n            var keyImage = document.createElement('img');\n            keyImage.src = './assets/keys/' + this.currentRoom.keyColor + '.png';\n            this.ctx.drawImage(keyImage, this.keyCollisionRect.x, this.keyCollisionRect.y);\n            if (this.isCollisionDetected(this.playerCollisionRect, this.keyCollisionRect)) {\n                this.keys.push(this.currentRoom.keyColor);\n                this.roomsOfFoundKeys.push(this.currentRoom.id);\n            }\n        }\n        // Draw keyhole and detect its collision with player\n        if (this.currentRoom.keyHoleColor != \"\" && this.currentRoom.wallCollisionRects[0].y == this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height) {\n            var keyHoleImg = document.createElement('img');\n            keyHoleImg.src = './assets/keyholes/' + this.currentRoom.keyHoleColor + '.png';\n            this.ctx.drawImage(keyHoleImg, this.keyHoleCollisionRect.x, this.keyHoleCollisionRect.y);\n            if (this.isCollisionDetected(this.playerCollisionRect, this.keyHoleCollisionRect) && this.keys.includes(this.currentRoom.keyHoleColor)) {\n                var newKeys = [];\n                for (var _h = 0, _j = this.keys; _h < _j.length; _h++) {\n                    var keyColor = _j[_h];\n                    if (keyColor != this.currentRoom.keyHoleColor) {\n                        newKeys.push(keyColor);\n                    }\n                }\n                this.keys = newKeys;\n                this.openingWallInterval = setInterval(function () {\n                    _this.currentRoom.wallCollisionRects[0].y += 1;\n                    _this.currentRoom.wallCollisionRects[0].height -= 1;\n                    if (_this.currentRoom.wallCollisionRects[0].height == 0) {\n                        clearInterval(_this.openingWallInterval);\n                        _this.openingWallInterval = null;\n                    }\n                }, this.frameLength / 2);\n            }\n        }\n        // Detect bullets' collisions with shadow, walls and enemies\n        var bulletsToDelete = [];\n        var enemiesToDelete = [];\n        for (var _k = 0, _l = this.playerBullets; _k < _l.length; _k++) {\n            var bullet = _l[_k];\n            if (bullet.collisionRect.x + bullet.collisionRect.width < 0 || bullet.collisionRect.x > 320 || bullet.collisionRect.y + bullet.collisionRect.height < 0 || bullet.collisionRect.y > 176) {\n                bulletsToDelete.push(bullet);\n            }\n            else {\n                if (this.isCollisionDetected(bullet.collisionRect, this.shadowCollisionRect)) {\n                    var bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\n                    var bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\n                    var bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\n                    for (var _m = 0, _o = this.enemies; _m < _o.length; _m++) {\n                        var neighbourEnemy = _o[_m];\n                        if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\n                            enemiesToDelete.push(neighbourEnemy);\n                        }\n                    }\n                    this.shadowFreezeTime = Date.now();\n                    bulletsToDelete.push(bullet);\n                }\n                else {\n                    for (var _p = 0, _q = this.currentRoom.wallCollisionRects; _p < _q.length; _p++) {\n                        var wall = _q[_p];\n                        if (this.isCollisionDetected(bullet.collisionRect, wall)) {\n                            bulletsToDelete.push(bullet);\n                            break;\n                        }\n                    }\n                    for (var _r = 0, _s = this.enemies; _r < _s.length; _r++) {\n                        var enemy = _s[_r];\n                        if (this.isCollisionDetected(bullet.collisionRect, enemy.collisionRect)) {\n                            var bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\n                            var bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\n                            var bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\n                            for (var _t = 0, _u = this.enemies; _t < _u.length; _t++) {\n                                var neighbourEnemy = _u[_t];\n                                if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\n                                    enemiesToDelete.push(neighbourEnemy);\n                                }\n                            }\n                            if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\n                                bulletsToDelete.push(bullet);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        this.score += 5 * enemiesToDelete.length;\n        if (enemiesToDelete.length == this.enemies.length && enemiesToDelete.length > 0) {\n            this.score += 200;\n            this.playerSpeed *= 2;\n        }\n        if (this.score > this.highScore) {\n            this.highScore = this.score;\n        }\n        var newEnemies = [];\n        for (var _v = 0, _w = this.enemies; _v < _w.length; _v++) {\n            var enemy = _w[_v];\n            if (!this.enemyArrayIncludes(enemiesToDelete, enemy)) {\n                newEnemies.push(enemy);\n            }\n        }\n        this.enemies = newEnemies;\n        var newBullets = [];\n        for (var _x = 0, _y = this.playerBullets; _x < _y.length; _x++) {\n            var bullet = _y[_x];\n            if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\n                newBullets.push(bullet);\n            }\n        }\n        this.playerBullets = newBullets;\n        this.frame += 1;\n    };\n    Game.prototype.setNewRoom = function (roomId) {\n        // console.log(this.rooms[roomId])\n        this.currentRoom = this.rooms[roomId];\n        // console.log(this.currentRoom)\n        this.playerSpeed = this.basicSpeed;\n        this.lastStartPosition = [this.playerCollisionRect.x, this.playerCollisionRect.y];\n        this.placeShadow();\n        this.createRoomBackground();\n        this.enemies = [];\n        this.playerBullets = [];\n        this.createEnemies(3);\n        this.placeKey();\n        this.placeKeyHole();\n        this.timeOfEnteringRoom = Date.now();\n        this.roomsTraveledSinceInjured += 1;\n    };\n    Game.prototype.takeDamage = function () {\n        this.playerSpeed = this.basicSpeed;\n        this.placeShadow();\n        if (this.playerLives == 0) {\n            this.die();\n        }\n        else {\n            this.playerLives--;\n            this.playerCollisionRect.x = this.lastStartPosition[0];\n            this.playerCollisionRect.y = this.lastStartPosition[1];\n            this.enemies = [];\n            this.playerBullets = [];\n            this.createEnemies(3);\n            this.placeKey();\n            this.placeKeyHole();\n            this.timeOfEnteringRoom = Date.now();\n            this.roomsTraveledSinceInjured = 1;\n        }\n    };\n    Game.prototype.die = function () {\n        // Reset score\n        this.score = 0;\n        // Reset keys\n        this.keys = [];\n        this.roomsOfFoundKeys = [];\n        // Reset keyholes\n        for (var _i = 0, _a = this.rooms; _i < _a.length; _i++) {\n            var room = _a[_i];\n            if (room.keyHoleColor != \"\" && room.wallCollisionRects[0].y != room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height) {\n                var oldY = room.wallCollisionRects[0].y;\n                room.wallCollisionRects[0].y = room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height;\n                room.wallCollisionRects[0].height = oldY - room.wallCollisionRects[0].y;\n            }\n        }\n        this.playerCollisionRect.x = 16;\n        this.playerCollisionRect.y = 176 / 2 - this.playerCollisionRect.height / 2;\n        this.setNewRoom(0);\n        this.playerLives = 4;\n    };\n    Game.prototype.createRoomBackground = function () {\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\n        // console.log(this.currentRoom.wallCollisionRects)\n        //Top left\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _i = 0, _a = this.currentRoom.wallCollisionRects; _i < _a.length; _i++) {\n                var wall = _a[_i];\n                // console.log(\"a\")\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    var wall = _c[_b];\n                    if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus - 8, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _d = 0, _e = this.currentRoom.wallCollisionRects; _d < _e.length; _d++) {\n                var wall = _e[_d];\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Bottom left\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\n                var wall = _g[_f];\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _h = 0, _j = this.currentRoom.wallCollisionRects; _h < _j.length; _h++) {\n                    var wall = _j[_h];\n                    if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus - 8, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _k = 0, _l = this.currentRoom.wallCollisionRects; _k < _l.length; _k++) {\n                var wall = _l[_k];\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Top right\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _m = 0, _o = this.currentRoom.wallCollisionRects; _m < _o.length; _m++) {\n                var wall = _o[_m];\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _p = 0, _q = this.currentRoom.wallCollisionRects; _p < _q.length; _p++) {\n                    var wall = _q[_p];\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _r = 0, _s = this.currentRoom.wallCollisionRects; _r < _s.length; _r++) {\n                var wall = _s[_r];\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Bottom right\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _t = 0, _u = this.currentRoom.wallCollisionRects; _t < _u.length; _t++) {\n                var wall = _u[_t];\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _v = 0, _w = this.currentRoom.wallCollisionRects; _v < _w.length; _v++) {\n                    var wall = _w[_v];\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _x = 0, _y = this.currentRoom.wallCollisionRects; _x < _y.length; _x++) {\n                var wall = _y[_x];\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // console.log(this.roomBackground)\n    };\n    Game.prototype.placeShadow = function () {\n        var shadowMargin = 15;\n        var shadowPlacements = [\n            [shadowMargin, shadowMargin],\n            [320 - shadowMargin - this.shadowCollisionRect.width, shadowMargin],\n            [320 - shadowMargin - this.shadowCollisionRect.width, 176 - shadowMargin - this.shadowCollisionRect.height],\n            [shadowMargin, 176 - shadowMargin - this.shadowCollisionRect.height]\n        ];\n        var newShadowPlacement = shadowPlacements[Math.floor(Math.random() * shadowPlacements.length)];\n        this.shadowCollisionRect.x = newShadowPlacement[0];\n        this.shadowCollisionRect.y = newShadowPlacement[1];\n    };\n    Game.prototype.moveShadow = function () {\n        var playerCenterX = this.playerCollisionRect.x + this.playerCollisionRect.width / 2;\n        var playerCenterY = this.playerCollisionRect.y + this.playerCollisionRect.height / 2;\n        var shadowCenterX = this.shadowCollisionRect.x + this.shadowCollisionRect.width / 2;\n        var shadowCenterY = this.shadowCollisionRect.y + this.shadowCollisionRect.height / 2;\n        if (this.shadowSpeed <= Math.abs(playerCenterX - shadowCenterX)) {\n            this.shadowCollisionRect.x += (playerCenterX - shadowCenterX) / Math.abs(playerCenterX - shadowCenterX) * this.shadowSpeed;\n        }\n        else {\n            this.shadowCollisionRect.x += playerCenterX - shadowCenterX;\n        }\n        if (this.shadowSpeed <= Math.abs(playerCenterY - shadowCenterY)) {\n            this.shadowCollisionRect.y += (playerCenterY - shadowCenterY) / Math.abs(playerCenterY - shadowCenterY) * this.shadowSpeed;\n        }\n        else {\n            this.shadowCollisionRect.y += playerCenterY - shadowCenterY;\n        }\n    };\n    Game.prototype.createEnemies = function (n) {\n        var i = 0;\n        while (i < n) {\n            var availableColors = [\"red\", 'green', 'blue', 'white'];\n            var newEnemyColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n            var newEnemy = new _Enemy__WEBPACK_IMPORTED_MODULE_1__[\"default\"](newEnemyColor);\n            newEnemy.setPosition(Math.floor(Math.random() * (320 - newEnemy.collisionRect.width)), Math.floor(Math.random() * (176 - newEnemy.collisionRect.height)));\n            var isAbleToAddEnemy = true;\n            for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                var backgroundLine = _a[_i];\n                if (this.isCollisionDetected(newEnemy.collisionRect, backgroundLine)) {\n                    isAbleToAddEnemy = false;\n                    break;\n                }\n            }\n            if (isAbleToAddEnemy) {\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    var wall = _c[_b];\n                    if (this.isCollisionDetected(newEnemy.collisionRect, wall)) {\n                        isAbleToAddEnemy = false;\n                        break;\n                    }\n                }\n            }\n            if (isAbleToAddEnemy) {\n                for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\n                    var enemy = _e[_d];\n                    if (this.isCollisionDetected(newEnemy.collisionRect, enemy.collisionRect)) {\n                        isAbleToAddEnemy = false;\n                        break;\n                    }\n                }\n            }\n            if (isAbleToAddEnemy) {\n                this.enemies.push(newEnemy);\n                i++;\n            }\n        }\n        // console.log(this.enemies)\n    };\n    Game.prototype.placeKey = function () {\n        if (this.currentRoom.keyColor != \"\") {\n            var isAbleToPlaceKey = void 0;\n            do {\n                isAbleToPlaceKey = true;\n                this.keyCollisionRect = { x: Math.floor(Math.random() * (320 - 14)), y: Math.floor(Math.random() * (176 - 6)), width: 14, height: 6 };\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                    var backgroundLine = _a[_i];\n                    if (this.isCollisionDetected(this.keyCollisionRect, backgroundLine)) {\n                        isAbleToPlaceKey = false;\n                        break;\n                    }\n                }\n                if (isAbleToPlaceKey) {\n                    for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                        var wall = _c[_b];\n                        if (this.isCollisionDetected(this.keyCollisionRect, wall)) {\n                            isAbleToPlaceKey = false;\n                            break;\n                        }\n                    }\n                }\n            } while (!isAbleToPlaceKey);\n        }\n    };\n    Game.prototype.placeKeyHole = function () {\n        if (this.currentRoom.keyHoleColor != \"\") {\n            var isAbleToPlaceKeyHole = void 0;\n            do {\n                isAbleToPlaceKeyHole = true;\n                var keyHoleX = Math.floor(320 * Math.floor(Math.random() * 5) / 5 + 320 / 10 - 16 / 2);\n                var keyHoleY = Math.floor(176 * Math.floor(Math.random() * 3) / 3 + 176 / 6 - 13 / 2);\n                this.keyHoleCollisionRect = { x: keyHoleX, y: keyHoleY, width: 16, height: 13 };\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                    var backgroundLine = _a[_i];\n                    if (this.isCollisionDetected(this.keyHoleCollisionRect, backgroundLine)) {\n                        isAbleToPlaceKeyHole = false;\n                        break;\n                    }\n                }\n            } while (!isAbleToPlaceKeyHole);\n        }\n    };\n    Game.prototype.playerDetectAction = function (e) {\n        var _this = this;\n        var key = e.key;\n        if (key == \"Control\") {\n            var movementforceX = 0;\n            var movementforceY = 0;\n            if (this.playerMovementsObject.goRight) {\n                movementforceX = 1;\n            }\n            else if (this.playerMovementsObject.goLeft) {\n                movementforceX = -1;\n            }\n            clearInterval(this.playerMovementsObject.goLeft);\n            this.playerMovementsObject.goLeft = null;\n            clearInterval(this.playerMovementsObject.goRight);\n            this.playerMovementsObject.goRight = null;\n            if (this.playerMovementsObject.goUp) {\n                movementforceY = -1;\n            }\n            else if (this.playerMovementsObject.goDown) {\n                movementforceY = 1;\n            }\n            clearInterval(this.playerMovementsObject.goDown);\n            this.playerMovementsObject.goDown = null;\n            clearInterval(this.playerMovementsObject.goUp);\n            this.playerMovementsObject.goUp = null;\n            this.isFireModeOn = true;\n            if ((movementforceX != 0 || movementforceY != 0) && this.isGunLoaded && this.playerBullets.length < 2) {\n                this.firePlayerBullet([movementforceX, movementforceY]);\n            }\n        }\n        else if (this.isFireModeOn && this.isGunLoaded) {\n            if (this.playerBullets.length < 2) {\n                switch (key) {\n                    case \"ArrowRight\":\n                        this.firePlayerBullet([1, 0]);\n                        break;\n                    case \"ArrowLeft\":\n                        this.firePlayerBullet([-1, 0]);\n                        break;\n                    case \"ArrowUp\":\n                        this.firePlayerBullet([0, -1]);\n                        break;\n                    case \"ArrowDown\":\n                        this.firePlayerBullet([0, 1]);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        else if (key == \"ArrowDown\" && !this.playerMovementsObject.goDown) {\n            this.playerMovementsObject.goDown = setInterval(function () {\n                if (_this.playerCollisionRect.y <= 1080 - _this.playerCollisionRect.height - _this.playerSpeed) {\n                    _this.playerCollisionRect.y += _this.playerSpeed;\n                }\n            }, this.frameLength);\n        }\n        else if (key == \"ArrowUp\" && !this.playerMovementsObject.goUp) {\n            this.playerMovementsObject.goUp = setInterval(function () {\n                if (_this.playerCollisionRect.y > 0) {\n                    _this.playerCollisionRect.y -= _this.playerSpeed;\n                }\n            }, this.frameLength);\n        }\n        else if (key == \"ArrowRight\" && !this.playerMovementsObject.goRight) {\n            this.playerMovementsObject.goRight = setInterval(function () {\n                if (_this.playerCollisionRect.x <= 1920 - _this.playerCollisionRect.width - _this.playerSpeed) {\n                    _this.playerCollisionRect.x += _this.playerSpeed;\n                }\n            }, this.frameLength);\n        }\n        else if (key == \"ArrowLeft\" && !this.playerMovementsObject.goLeft) {\n            this.playerMovementsObject.goLeft = setInterval(function () {\n                if (_this.playerCollisionRect.x > 0) {\n                    _this.playerCollisionRect.x -= _this.playerSpeed;\n                }\n            }, this.frameLength);\n        }\n    };\n    Game.prototype.playerStopAction = function (e) {\n        var key = e.key;\n        if (key == \"Control\") {\n            this.isFireModeOn = false;\n        }\n        else if (key == \"ArrowDown\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goDown);\n            this.playerMovementsObject.goDown = null;\n        }\n        else if (key == \"ArrowUp\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goUp);\n            this.playerMovementsObject.goUp = null;\n        }\n        else if (key == \"ArrowRight\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goRight);\n            this.playerMovementsObject.goRight = null;\n        }\n        else if (key == \"ArrowLeft\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goLeft);\n            this.playerMovementsObject.goLeft = null;\n        }\n    };\n    Game.prototype.firePlayerBullet = function (movementForces) {\n        this.isGunLoaded = false;\n        var newBullet = new _Bullet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.bulletsFired, movementForces);\n        var horizontalCenterDistance = (this.playerCollisionRect.width / 2 + newBullet.width / 2);\n        var verticalCenterDistance = (this.playerCollisionRect.height / 2 + newBullet.height / 2);\n        var newBulletX = Math.floor(this.playerCollisionRect.x + this.playerCollisionRect.width / 2 + horizontalCenterDistance * movementForces[0] - newBullet.width / 2);\n        var newBulletY = Math.floor(this.playerCollisionRect.y + this.playerCollisionRect.height / 2 + verticalCenterDistance * movementForces[1] - newBullet.height / 2);\n        newBullet.setCoords(newBulletX, newBulletY);\n        this.playerBullets.push(newBullet);\n        this.bulletsFired += 1;\n    };\n    Game.prototype.moveEnemies = function () {\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\n            var enemy = _a[_i];\n            // Horizontal\n            var horizontalDistance = this.playerCollisionRect.x - enemy.collisionRect.x;\n            for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x); i += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed) {\n                var didHitWall = false;\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    var wall = _c[_b];\n                    if (this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\n                        didHitWall = true;\n                        horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                        break;\n                    }\n                }\n                if (!didHitWall) {\n                    for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\n                        var encounteredEnemmy = _e[_d];\n                        if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\n                            didHitWall = true;\n                            horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                            break;\n                        }\n                    }\n                }\n                if (didHitWall) {\n                    break;\n                }\n            }\n            // Vertical\n            var verticalDistance = this.playerCollisionRect.y - enemy.collisionRect.y;\n            for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y); i += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed) {\n                var didHitWall = false;\n                for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\n                    var wall = _g[_f];\n                    if (this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\n                        didHitWall = true;\n                        verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                        break;\n                    }\n                }\n                if (!didHitWall) {\n                    for (var _h = 0, _j = this.enemies; _h < _j.length; _h++) {\n                        var encounteredEnemmy = _j[_h];\n                        if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\n                            didHitWall = true;\n                            verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                            break;\n                        }\n                    }\n                }\n                if (didHitWall) {\n                    break;\n                }\n            }\n            // if(enemy.color == 'red'){\n            //     console.log(horizontalDistance, verticalDistance)\n            // }\n            if (Math.abs(horizontalDistance) > Math.abs(verticalDistance) && Math.abs(horizontalDistance) >= this.playerSpeed) {\n                // if(Math.abs(horizontalDistance) >= enemy.speed)\n                enemy.collisionRect.x += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                // else\n                //     enemy.collisionRect.x += Math.floor(horizontalDistance)\n            }\n            else if (Math.abs(verticalDistance) >= this.playerSpeed) {\n                // if(Math.abs(verticalDistance) >= enemy.speed)\n                enemy.collisionRect.y += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                // else\n                //     enemy.collisionRect.y += Math.floor(verticalDistance)\n            }\n        }\n    };\n    Game.prototype.isNumberBetween = function (n, min, max) {\n        return n >= min && n <= max;\n    };\n    Game.prototype.isCollisionDetected = function (cr1, cr2) {\n        if (cr1.x + cr1.width > cr2.x\n            && cr1.x < cr2.x + cr2.width\n            && cr1.y + cr1.height > cr2.y\n            && cr1.y < cr2.y + cr2.height) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Game.prototype.enemyArrayIncludes = function (enemyArray, enemyToCheck) {\n        for (var _i = 0, enemyArray_1 = enemyArray; _i < enemyArray_1.length; _i++) {\n            var enemy = enemyArray_1[_i];\n            if (enemyToCheck.equals(enemy))\n                return true;\n        }\n        return false;\n    };\n    Game.prototype.bulletArrayIncludes = function (bulletArray, bulletToCheck) {\n        for (var _i = 0, bulletArray_1 = bulletArray; _i < bulletArray_1.length; _i++) {\n            var bullet = bulletArray_1[_i];\n            if (bulletToCheck.id == bullet.id)\n                return true;\n        }\n        return false;\n    };\n    return Game;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Game);\n\n\n//# sourceURL=webpack://shamus/./src/Game.ts?");

/***/ }),

/***/ "./src/Room.ts":
/*!*********************!*\
  !*** ./src/Room.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Room = /** @class */ (function () {\n    function Room(id, levelColor, bgColor, wallCollisionRects, neighbourRoomsIds, keyColor, keyHoleColor) {\n        this.id = id;\n        this.levelColor = levelColor;\n        this.bgColor = bgColor;\n        this.wallCollisionRects = wallCollisionRects;\n        this.neighbourRoomsIds = neighbourRoomsIds;\n        this.keyColor = keyColor;\n        this.keyHoleColor = keyHoleColor;\n    }\n    return Room;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Room);\n\n\n//# sourceURL=webpack://shamus/./src/Room.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\n\nvar newGame = new _Game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n\n//# sourceURL=webpack://shamus/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;