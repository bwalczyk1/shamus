/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Bullet.ts":
/*!***********************!*\
  !*** ./src/Bullet.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Bullet = /** @class */ (function () {\n    function Bullet(id, movementForces) {\n        this.speed = 9;\n        this.id = id;\n        if (movementForces[0] == 0) {\n            this.type = \"vertical\";\n        }\n        else if (movementForces[1] == 0) {\n            this.type = \"horizontal\";\n        }\n        else if (movementForces[0] == movementForces[1]) {\n            this.type = \"diagonal\";\n        }\n        else {\n            this.type = \"diagonalInverted\";\n        }\n        this.speedX = movementForces[0] * this.speed;\n        this.speedY = movementForces[1] * this.speed;\n        if (this.type == \"horizontal\") {\n            this.width = 8;\n            this.height = 3;\n        }\n        else if (this.type == \"vertical\") {\n            this.width = 4;\n            this.height = 6;\n        }\n        else if (this.type == \"diagonal\" || this.type == \"diagonalInverted\") {\n            this.width = 4;\n            this.height = 4;\n        }\n    }\n    Bullet.prototype.setCoords = function (x, y) {\n        this.collisionRect = { x: x - this.speedX, y: y - this.speedY, width: this.width, height: this.height };\n    };\n    Bullet.prototype.move = function () {\n        this.collisionRect.x += this.speedX;\n        this.collisionRect.y += this.speedY;\n    };\n    return Bullet;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Bullet);\n\n\n//# sourceURL=webpack://shamus/./src/Bullet.ts?");

/***/ }),

/***/ "./src/Enemy.ts":
/*!**********************!*\
  !*** ./src/Enemy.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Enemy = /** @class */ (function () {\n    function Enemy(type) {\n        this.collisionRect = { x: 0, y: 0, width: 16, height: 8 };\n        this.movementObject = { endFrame: 0, forceX: 0, forceY: 0 };\n        this.type = type;\n        var availableColors;\n        switch (type) {\n            case 0:\n                availableColors = [\"red\", 'green', 'blue', 'white'];\n                this.speed = 3;\n                break;\n            case 1:\n                availableColors = [\"yellow\"];\n                //availableColors = [\"yellow\", \"cyan\", 'white']\n                this.speed = 2;\n                break;\n            default:\n                availableColors = [\"green\"];\n                this.collisionRect = { x: 0, y: 0, width: 12, height: 8 };\n                this.speed = 16;\n                break;\n        }\n        this.color = availableColors[Math.floor(Math.random() * availableColors.length)];\n    }\n    Enemy.prototype.setPosition = function (x, y) {\n        this.collisionRect.x = x;\n        this.collisionRect.y = y;\n    };\n    Enemy.prototype.equals = function (enemy) {\n        if (this.collisionRect.x == enemy.collisionRect.x && this.collisionRect.y == enemy.collisionRect.y) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    return Enemy;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Enemy);\n\n\n//# sourceURL=webpack://shamus/./src/Enemy.ts?");

/***/ }),

/***/ "./src/Game.ts":
/*!*********************!*\
  !*** ./src/Game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Bullet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bullet */ \"./src/Bullet.ts\");\n/* harmony import */ var _Enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Enemy */ \"./src/Enemy.ts\");\n/* harmony import */ var _Room__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Room */ \"./src/Room.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nvar Game = /** @class */ (function () {\n    function Game() {\n        var _this = this;\n        this.frame = 0;\n        this.animationFrame = 0;\n        this.frameLength = 100;\n        this.rooms = [];\n        this.playerCollisionRect = { x: 0, y: 0, width: 14, height: 17 };\n        this.shadowCollisionRect = { x: 0, y: 0, width: 18, height: 15 };\n        this.basicSpeed = 1;\n        this.playerSpeed = this.basicSpeed;\n        this.shadowSpeed = 7;\n        this.shadowFreezeTime = 0;\n        this.playerMovementsObject = {};\n        this.enemies = [];\n        this.lastStartPosition = [16, Math.floor(176 / 2 - this.playerCollisionRect.height / 2)];\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\n        this.isFireModeOn = false;\n        this.isGunLoaded = true;\n        this.playerBullets = [];\n        this.playerLives = 4;\n        this.score = 0;\n        this.highScore = 0;\n        this.bulletsFired = 0;\n        this.roomsTraveledSinceInjured = 0;\n        this.keys = [];\n        this.roomsOfFoundKeys = [];\n        this.bulletsAnimations = [];\n        this.startTime = Date.now();\n        this.gameScreen = document.getElementById(\"gameScreen\");\n        // this.gameScreen.style.width = document.body.style.width;\n        // this.gameScreen.style.height = document.body.style.height;\n        this.ctx = this.gameScreen.getContext('2d');\n        this.ctx.imageSmoothingEnabled = false;\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_2__[\"default\"](10, \"black\", \"yellow\", [\n            { x: 0, y: 64, width: 8, height: 48 },\n            { x: 0, y: 56, width: 56, height: 8 },\n            { x: 48, y: 8, width: 8, height: 48 },\n            { x: 48, y: 0, width: 224, height: 8 },\n            { x: 264, y: 8, width: 8, height: 48 },\n            { x: 264, y: 56, width: 56, height: 8 },\n            { x: 264, y: 112, width: 56, height: 8 },\n            { x: 264, y: 120, width: 8, height: 48 },\n            { x: 48, y: 168, width: 224, height: 8 },\n            { x: 48, y: 120, width: 8, height: 48 },\n            { x: 0, y: 112, width: 128, height: 8 },\n            { x: 120, y: 56, width: 8, height: 56 },\n            { x: 128, y: 56, width: 64, height: 8 },\n            { x: 192, y: 56, width: 8, height: 56 }\n        ], [null, 1, null, null], \"blue\", \"\"));\n        this.rooms.push(new _Room__WEBPACK_IMPORTED_MODULE_2__[\"default\"](21, \"black\", \"yellow\", [\n            { x: 320 - 8, y: 56 + 8, width: 8, height: 112 - 56 - 8 },\n            { x: 0, y: 112, width: 320, height: 8 },\n            { x: 0, y: 56, width: 320, height: 8 }\n        ], [null, null, null, 0], \"\", \"blue\"));\n        this.playerCollisionRect.x = this.lastStartPosition[0];\n        this.playerCollisionRect.y = this.lastStartPosition[1];\n        this.setNewRoom(0);\n        document.addEventListener(\"keydown\", function (event) { _this.playerDetectAction(event); });\n        document.addEventListener(\"keyup\", function (event) { _this.playerStopAction(event); });\n        // setInterval(() => {this.refreshScreen()}, this.frameLength)\n        window.requestAnimationFrame(function () { return _this.refreshScreen(); });\n    }\n    Game.prototype.refreshScreen = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var isShadowFrozen, isShadowInMmove, newX, newY, shadowImg, wallImg, _i, _a, backgroundLine, i, _b, _c, wall, realFrame, i, i, i, highScoreString, i, digitString, digitImg, digitX, scoreString, i, digitString, digitImg, digitX, lifeImg, i, blueKeyImage, interfaceImage, roomString, i, digitString, digitImg, digitX, playerImg, _d, _e, enemy, enemyPhase, enemyImg, droidMovementPhase, _f, _g, bullet, bulletImg, keyImage, keyHoleImg, newKeys, _h, _j, keyColor, newBulletsAnimations, _k, _l, bulletAnimation, bulletAnimationImage, bulletsToDelete, enemiesToDelete, _m, _o, bullet, bulletBlastX, bulletBlastY, bulletBlast, _p, _q, neighbourEnemy, _r, _s, wall, bulletBlastX, bulletBlastY, _t, _u, enemy, bulletBlastX, bulletBlastY, bulletBlast, _v, _w, neighbourEnemy, newEnemies, _x, _y, enemy, newBullets, _z, _0, bullet;\n            var _this = this;\n            return __generator(this, function (_1) {\n                console.log(this.playerCollisionRect.x);\n                this.ctx = this.gameScreen.getContext('2d');\n                this.ctx.clearRect(0, 0, 320, 208);\n                // this.ctx.fillStyle = \"black\"\n                // this.ctx.fillRect(0, 0, 320, 208)\n                //Detect room change\n                if (this.playerCollisionRect.y < 0) {\n                    this.setNewRoom(this.currentRoom.neighbourRoomsIds[0]);\n                }\n                else if (this.playerCollisionRect.x + this.playerCollisionRect.width > 320) {\n                    this.playerCollisionRect.x = 16;\n                    this.setNewRoom(this.currentRoom.neighbourRoomsIds[1]);\n                }\n                else if (this.playerCollisionRect.y + this.playerCollisionRect.height > 176) {\n                    this.setNewRoom(this.currentRoom.neighbourRoomsIds[2]);\n                }\n                else if (this.playerCollisionRect.x < 0) {\n                    this.playerCollisionRect.x = 320 - 16 - this.playerCollisionRect.width;\n                    this.setNewRoom(this.currentRoom.neighbourRoomsIds[3]);\n                }\n                // Draw shadow and detect collision with player\n                if (Date.now() - this.timeOfEnteringRoom >= 15000) {\n                    isShadowFrozen = (Date.now() - this.shadowFreezeTime <= 2500);\n                    isShadowInMmove = Date.now() - this.timeOfEnteringRoom >= 17500;\n                    if (isShadowInMmove && !isShadowFrozen && this.canReallyAnimate()) {\n                        newX = void 0, newY = void 0;\n                        if (this.frame % 2 == 1) {\n                            newX = this.shadowCollisionRect.x - 2;\n                            newY = this.shadowCollisionRect.y + 2;\n                            this.shadowCollisionRect = { x: newX, y: newY, width: 22, height: 11 };\n                        }\n                        else {\n                            newX = this.shadowCollisionRect.x + 2;\n                            newY = this.shadowCollisionRect.y - 2;\n                            this.shadowCollisionRect = { x: newX, y: newY, width: 18, height: 15 };\n                        }\n                        this.moveShadow();\n                    }\n                    shadowImg = document.createElement('img');\n                    if (isShadowFrozen) {\n                        shadowImg.src = './assets/enemies/shadow/frozen' + this.shadowFreezeTime % 2 + '.png';\n                    }\n                    else if (isShadowInMmove) {\n                        shadowImg.src = './assets/enemies/shadow/' + this.frame % 2 + '.png';\n                    }\n                    else {\n                        shadowImg.src = './assets/enemies/shadow/0.png';\n                    }\n                    this.ctx.drawImage(shadowImg, this.shadowCollisionRect.x, this.shadowCollisionRect.y);\n                    if (this.isCollisionDetected(this.shadowCollisionRect, this.playerCollisionRect)) {\n                        this.takeDamage();\n                        return [2 /*return*/];\n                    }\n                }\n                wallImg = document.createElement('img');\n                wallImg.src = './assets/background/' + this.currentRoom.bgColor + '.png';\n                for (_i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                    backgroundLine = _a[_i];\n                    for (i = 0; i < backgroundLine.width; i += 8) {\n                        this.ctx.drawImage(wallImg, backgroundLine.x + i, backgroundLine.y);\n                    }\n                }\n                // Draw walls and detect their collisions with player\n                for (_b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    wall = _c[_b];\n                    if (this.currentRoom.levelColor == \"black\") {\n                        this.ctx.fillStyle = \"white\";\n                    }\n                    else {\n                        this.ctx.fillStyle = this.currentRoom.levelColor;\n                    }\n                    if (this.isCollisionDetected(wall, this.playerCollisionRect)) {\n                        this.takeDamage();\n                        return [2 /*return*/];\n                    }\n                    this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);\n                    this.ctx.fillStyle = \"blue\";\n                    if (wall == this.currentRoom.wallCollisionRects[0]) {\n                        realFrame = this.frame - (wall.y - (this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height)) / 2;\n                        for (i = 0; i < wall.height; i += 8) {\n                            this.ctx.fillRect(wall.x, wall.y + i + realFrame % 4 * 2, wall.width, 2);\n                        }\n                    }\n                    else if (wall.width >= wall.height) {\n                        for (i = 0; i < wall.width; i += 8) {\n                            this.ctx.fillRect(wall.x + i + this.frame % 4 * 2, wall.y, 2, wall.height);\n                        }\n                    }\n                    else {\n                        for (i = 0; i < wall.height; i += 8) {\n                            this.ctx.fillRect(wall.x, wall.y + i + this.frame % 4 * 2, wall.width, 2);\n                        }\n                    }\n                }\n                // Draw interface\n                // Highscore\n                this.ctx.clearRect(0, 2 * 8, 6 * 8, 8);\n                highScoreString = this.highScore.toString();\n                for (i = 0; i < highScoreString.length; i++) {\n                    digitString = highScoreString[i];\n                    digitImg = document.createElement('img');\n                    digitImg.src = './assets/highscoreDigits/' + digitString + '.png';\n                    digitX = 6 * 8 - (highScoreString.length - i) * 8;\n                    this.ctx.drawImage(digitImg, digitX, 2 * 8);\n                }\n                // Score\n                this.ctx.clearRect(0, 4 * 8, 6 * 8, 8);\n                scoreString = this.score.toString();\n                for (i = 0; i < scoreString.length; i++) {\n                    digitString = scoreString[i];\n                    digitImg = document.createElement('img');\n                    digitImg.src = './assets/digits/' + digitString + '.png';\n                    digitX = 6 * 8 - (scoreString.length - i) * 8;\n                    this.ctx.drawImage(digitImg, digitX, 4 * 8);\n                }\n                // Lives\n                this.ctx.clearRect(320 - 6 * 8, 8, 6 * 8, 6 * 8);\n                lifeImg = document.createElement('img');\n                lifeImg.src = './assets/playerLife.png';\n                for (i = 1; i <= this.playerLives; i++) {\n                    this.ctx.drawImage(lifeImg, 320 - 6 * 8 + (i - 1) % 3 * 16, 8 + Math.floor((i - 1) / 3) * 16);\n                }\n                // Room info and inventory\n                this.ctx.clearRect(0, 208 - 4 * 8, 320, 4 * 8);\n                // - Keys\n                if (this.keys.includes(\"blue\")) {\n                    blueKeyImage = document.createElement('img');\n                    blueKeyImage.src = './assets/keys/blue.png';\n                    this.ctx.drawImage(blueKeyImage, 7 * 16 + 1, 176 + 1);\n                }\n                interfaceImage = document.createElement('img');\n                interfaceImage.src = './assets/interface.png';\n                this.ctx.drawImage(interfaceImage, 8 + 1, 176 + 8);\n                roomString = this.currentRoom.id.toString();\n                for (i = 0; i < roomString.length; i++) {\n                    digitString = roomString[i];\n                    digitImg = document.createElement('img');\n                    digitImg.src = './assets/digits/' + digitString + '.png';\n                    digitX = (7 + i) * 8;\n                    this.ctx.drawImage(digitImg, digitX, 176 + 8);\n                }\n                playerImg = document.createElement('img');\n                if (this.playerMovementsObject.goRight) {\n                    playerImg.src = './assets/player/right/' + (this.frame % 2) + '.png';\n                }\n                else if (this.playerMovementsObject.goLeft) {\n                    playerImg.src = './assets/player/left/' + (this.frame % 2) + '.png';\n                }\n                else if (this.playerMovementsObject.goUp || this.playerMovementsObject.goDown) {\n                    playerImg.src = './assets/player/vert/' + (this.frame % 2) + '.png';\n                }\n                else {\n                    playerImg.src = './assets/player/still.png';\n                }\n                this.ctx.drawImage(playerImg, this.playerCollisionRect.x, this.playerCollisionRect.y);\n                // Move enemies\n                if (this.canReallyAnimate())\n                    this.moveEnemies();\n                console.log('bb');\n                // Draw enemies and detect their collisions with player\n                for (_d = 0, _e = this.enemies; _d < _e.length; _d++) {\n                    enemy = _e[_d];\n                    if (this.isCollisionDetected(this.playerCollisionRect, enemy.collisionRect)) {\n                        this.takeDamage();\n                        return [2 /*return*/];\n                    }\n                    else {\n                        enemyPhase = this.frame % 4;\n                        enemyImg = document.createElement('img');\n                        switch (enemy.type) {\n                            case 0:\n                                enemyImg.src = './assets/enemies/drone/' + enemy.color + '/' + enemyPhase + '.png';\n                                break;\n                            case 1:\n                                droidMovementPhase = void 0;\n                                if (enemy.movementObject.forceX != 0)\n                                    droidMovementPhase = enemyPhase % 2;\n                                else if (enemy.movementObject.forceY != 0)\n                                    droidMovementPhase = enemyPhase % 2 + 1;\n                                else\n                                    droidMovementPhase = enemyPhase % 2 * 2;\n                                enemyImg.src = './assets/enemies/droid/' + enemy.color + '/' + enemyPhase + '_' + droidMovementPhase + '.png';\n                                break;\n                            default:\n                                enemyImg.src = './assets/enemies/jumper/' + enemyPhase + '.png';\n                                break;\n                        }\n                        this.ctx.drawImage(enemyImg, enemy.collisionRect.x, enemy.collisionRect.y);\n                    }\n                }\n                // Move and draw bullets\n                for (_f = 0, _g = this.playerBullets; _f < _g.length; _f++) {\n                    bullet = _g[_f];\n                    if (this.canReallyAnimate())\n                        bullet.move();\n                    bulletImg = document.createElement('img');\n                    bulletImg.src = './assets/bullets/' + bullet.type + '.png';\n                    if (bullet.type == \"diagonal\" || bullet.type == \"diagonalInverted\") {\n                        this.ctx.drawImage(bulletImg, bullet.collisionRect.x - 1, bullet.collisionRect.y - 1);\n                    }\n                    else {\n                        this.ctx.drawImage(bulletImg, bullet.collisionRect.x, bullet.collisionRect.y);\n                    }\n                }\n                // Draw key and detect its collision with player\n                if (this.currentRoom.keyColor != \"\" && !this.roomsOfFoundKeys.includes(this.currentRoom.id)) {\n                    keyImage = document.createElement('img');\n                    keyImage.src = './assets/keys/' + this.currentRoom.keyColor + '.png';\n                    this.ctx.drawImage(keyImage, this.keyCollisionRect.x, this.keyCollisionRect.y);\n                    if (this.isCollisionDetected(this.playerCollisionRect, this.keyCollisionRect)) {\n                        this.keys.push(this.currentRoom.keyColor);\n                        this.roomsOfFoundKeys.push(this.currentRoom.id);\n                    }\n                }\n                // Draw keyhole and detect its collision with player\n                if (this.currentRoom.keyHoleColor != \"\" && this.currentRoom.wallCollisionRects[0].y == this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].y + this.currentRoom.wallCollisionRects[this.currentRoom.wallCollisionRects.length - 1].height) {\n                    keyHoleImg = document.createElement('img');\n                    keyHoleImg.src = './assets/keyholes/' + this.currentRoom.keyHoleColor + '.png';\n                    this.ctx.drawImage(keyHoleImg, this.keyHoleCollisionRect.x, this.keyHoleCollisionRect.y);\n                    if (this.isCollisionDetected(this.playerCollisionRect, this.keyHoleCollisionRect) && this.keys.includes(this.currentRoom.keyHoleColor)) {\n                        newKeys = [];\n                        for (_h = 0, _j = this.keys; _h < _j.length; _h++) {\n                            keyColor = _j[_h];\n                            if (keyColor != this.currentRoom.keyHoleColor) {\n                                newKeys.push(keyColor);\n                            }\n                        }\n                        this.keys = newKeys;\n                        this.openingWallInterval = setInterval(function () {\n                            if (_this.currentRoom.keyHoleColor != \"\") {\n                                _this.currentRoom.wallCollisionRects[0].y += 1;\n                                _this.currentRoom.wallCollisionRects[0].height -= 1;\n                                if (_this.currentRoom.wallCollisionRects[0].height == 0) {\n                                    clearInterval(_this.openingWallInterval);\n                                    _this.openingWallInterval = null;\n                                }\n                            }\n                        }, this.frameLength / 2);\n                    }\n                }\n                newBulletsAnimations = [];\n                for (_k = 0, _l = this.bulletsAnimations; _k < _l.length; _k++) {\n                    bulletAnimation = _l[_k];\n                    if (this.frame - bulletAnimation.startFrame < 4) {\n                        bulletAnimationImage = document.createElement('img');\n                        bulletAnimationImage.src = './assets/bulletExplosions/' + (this.frame - bulletAnimation.startFrame) + '.png';\n                        this.ctx.drawImage(bulletAnimationImage, bulletAnimation.x, bulletAnimation.y);\n                        newBulletsAnimations.push(bulletAnimation);\n                    }\n                }\n                this.bulletsAnimations = newBulletsAnimations;\n                bulletsToDelete = [];\n                enemiesToDelete = [];\n                for (_m = 0, _o = this.playerBullets; _m < _o.length; _m++) {\n                    bullet = _o[_m];\n                    if (bullet.collisionRect.x + bullet.collisionRect.width < 0 || bullet.collisionRect.x > 320 || bullet.collisionRect.y + bullet.collisionRect.height < 0 || bullet.collisionRect.y > 176) {\n                        bulletsToDelete.push(bullet);\n                    }\n                    else {\n                        if (this.isCollisionDetected(bullet.collisionRect, this.shadowCollisionRect)) {\n                            bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\n                            bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\n                            bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\n                            for (_p = 0, _q = this.enemies; _p < _q.length; _p++) {\n                                neighbourEnemy = _q[_p];\n                                if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\n                                    enemiesToDelete.push(neighbourEnemy);\n                                }\n                            }\n                            this.shadowFreezeTime = Math.floor(Date.now() / 2) * 2;\n                            bulletsToDelete.push(bullet);\n                            this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\n                        }\n                        else {\n                            for (_r = 0, _s = this.currentRoom.wallCollisionRects; _r < _s.length; _r++) {\n                                wall = _s[_r];\n                                if (this.isCollisionDetected(bullet.collisionRect, wall)) {\n                                    bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\n                                    bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\n                                    bulletsToDelete.push(bullet);\n                                    this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\n                                    break;\n                                }\n                            }\n                            for (_t = 0, _u = this.enemies; _t < _u.length; _t++) {\n                                enemy = _u[_t];\n                                if (this.isCollisionDetected(bullet.collisionRect, enemy.collisionRect)) {\n                                    bulletBlastX = bullet.collisionRect.x + bullet.width / 2 - 24 / 2;\n                                    bulletBlastY = bullet.collisionRect.y + bullet.height / 2 - 24 / 2;\n                                    bulletBlast = { x: bulletBlastX, y: bulletBlastY, width: 24, height: 24 };\n                                    for (_v = 0, _w = this.enemies; _v < _w.length; _v++) {\n                                        neighbourEnemy = _w[_v];\n                                        if (this.isCollisionDetected(bulletBlast, neighbourEnemy.collisionRect) && !this.enemyArrayIncludes(enemiesToDelete, neighbourEnemy)) {\n                                            enemiesToDelete.push(neighbourEnemy);\n                                        }\n                                    }\n                                    if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\n                                        bulletsToDelete.push(bullet);\n                                        this.bulletsAnimations.push({ startFrame: this.frame + 1, x: bulletBlastX, y: bulletBlastY });\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                this.score += 5 * enemiesToDelete.length;\n                if (enemiesToDelete.length == this.enemies.length && enemiesToDelete.length > 0) {\n                    this.score += 200;\n                    this.playerSpeed *= 2;\n                }\n                if (this.score > this.highScore) {\n                    this.highScore = this.score;\n                }\n                newEnemies = [];\n                for (_x = 0, _y = this.enemies; _x < _y.length; _x++) {\n                    enemy = _y[_x];\n                    if (!this.enemyArrayIncludes(enemiesToDelete, enemy)) {\n                        newEnemies.push(enemy);\n                    }\n                }\n                this.enemies = newEnemies;\n                newBullets = [];\n                for (_z = 0, _0 = this.playerBullets; _z < _0.length; _z++) {\n                    bullet = _0[_z];\n                    if (!this.bulletArrayIncludes(bulletsToDelete, bullet)) {\n                        newBullets.push(bullet);\n                    }\n                }\n                this.playerBullets = newBullets;\n                if (this.canReallyAnimate())\n                    this.frame += 1;\n                this.animationFrame += 1;\n                console.log('aa');\n                window.requestAnimationFrame(function () { return _this.refreshScreen(); });\n                return [2 /*return*/];\n            });\n        });\n    };\n    Game.prototype.setNewRoom = function (roomId) {\n        this.currentRoom = this.rooms[roomId];\n        this.playerSpeed = this.basicSpeed;\n        this.lastStartPosition = [this.playerCollisionRect.x, this.playerCollisionRect.y];\n        this.placeShadow();\n        this.createRoomBackground();\n        this.enemies = [];\n        this.playerBullets = [];\n        this.createEnemies(3);\n        this.placeKey();\n        this.placeKeyHole();\n        this.timeOfEnteringRoom = Date.now();\n        this.roomsTraveledSinceInjured += 1;\n    };\n    Game.prototype.takeDamage = function () {\n        var _this = this;\n        this.playerSpeed = this.basicSpeed;\n        this.placeShadow();\n        if (this.playerLives == 0) {\n            this.die();\n        }\n        else {\n            this.playerLives--;\n            this.playerCollisionRect.x = this.lastStartPosition[0];\n            this.playerCollisionRect.y = this.lastStartPosition[1];\n            this.enemies = [];\n            this.playerBullets = [];\n            this.createEnemies(3);\n            this.placeKey();\n            this.placeKeyHole();\n            this.timeOfEnteringRoom = Date.now();\n            this.roomsTraveledSinceInjured = 1;\n        }\n        window.requestAnimationFrame(function () { return _this.refreshScreen(); });\n    };\n    Game.prototype.die = function () {\n        // Reset score\n        this.score = 0;\n        // Reset keys\n        this.keys = [];\n        this.roomsOfFoundKeys = [];\n        // Reset keyholes\n        for (var _i = 0, _a = this.rooms; _i < _a.length; _i++) {\n            var room = _a[_i];\n            if (room.keyHoleColor != \"\" && room.wallCollisionRects[0].y != room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height) {\n                var oldY = room.wallCollisionRects[0].y;\n                room.wallCollisionRects[0].y = room.wallCollisionRects[room.wallCollisionRects.length - 1].y + room.wallCollisionRects[room.wallCollisionRects.length - 1].height;\n                room.wallCollisionRects[0].height = oldY - room.wallCollisionRects[0].y;\n            }\n        }\n        this.playerCollisionRect.x = 16;\n        this.playerCollisionRect.y = 176 / 2 - this.playerCollisionRect.height / 2;\n        this.setNewRoom(0);\n        this.playerLives = 4;\n    };\n    Game.prototype.createRoomBackground = function () {\n        this.roomBackground = [{ x: 0, y: 176, width: 320, height: 32 }];\n        //Top left\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _i = 0, _a = this.currentRoom.wallCollisionRects; _i < _a.length; _i++) {\n                var wall = _a[_i];\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    var wall = _c[_b];\n                    if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus - 8, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 0, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _d = 0, _e = this.currentRoom.wallCollisionRects; _d < _e.length; _d++) {\n                var wall = _e[_d];\n                if (this.isCollisionDetected({ x: 0, y: heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Bottom left\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\n                var wall = _g[_f];\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _h = 0, _j = this.currentRoom.wallCollisionRects; _h < _j.length; _h++) {\n                    var wall = _j[_h];\n                    if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus - 8, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 0, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _k = 0, _l = this.currentRoom.wallCollisionRects; _k < _l.length; _k++) {\n                var wall = _l[_k];\n                if (this.isCollisionDetected({ x: 0, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Top right\n        for (var heightBonus = 0; heightBonus < 176 / 2; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _m = 0, _o = this.currentRoom.wallCollisionRects; _m < _o.length; _m++) {\n                var wall = _o[_m];\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _p = 0, _q = this.currentRoom.wallCollisionRects; _p < _q.length; _p++) {\n                    var wall = _q[_p];\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _r = 0, _s = this.currentRoom.wallCollisionRects; _r < _s.length; _r++) {\n                var wall = _s[_r];\n                if (this.isCollisionDetected({ x: 320 - 8, y: heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n        // Bottom right\n        for (var heightBonus = 0; heightBonus < 176 / 2 - 16; heightBonus += 16) {\n            var canCreateBackground = true;\n            for (var _t = 0, _u = this.currentRoom.wallCollisionRects; _t < _u.length; _t++) {\n                var wall = _u[_t];\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus + 8, width: 8, height: 8 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n            for (var widthBonus = 0; widthBonus <= 320 / 2 - 8; widthBonus += 8) {\n                var canExtendBackground = true;\n                for (var _v = 0, _w = this.currentRoom.wallCollisionRects; _v < _w.length; _v++) {\n                    var wall = _w[_v];\n                    if (this.isCollisionDetected({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus + 8, width: 8 + widthBonus, height: 8 }, wall)) {\n                        canExtendBackground = false;\n                        this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                        break;\n                    }\n                }\n                if (!canExtendBackground) {\n                    break;\n                }\n                else if (widthBonus == 320 / 2 - 8) {\n                    this.roomBackground.push({ x: 320 - 8 - widthBonus, y: 176 - 16 - heightBonus, width: 8 + widthBonus, height: 16 });\n                }\n            }\n            for (var _x = 0, _y = this.currentRoom.wallCollisionRects; _x < _y.length; _x++) {\n                var wall = _y[_x];\n                if (this.isCollisionDetected({ x: 320 - 8, y: 176 - 16 - heightBonus, width: 8, height: 16 }, wall)) {\n                    canCreateBackground = false;\n                    break;\n                }\n            }\n            if (!canCreateBackground) {\n                break;\n            }\n        }\n    };\n    Game.prototype.placeShadow = function () {\n        var shadowMargin = 15;\n        var shadowPlacements = [\n            [shadowMargin, shadowMargin],\n            [320 - shadowMargin - this.shadowCollisionRect.width, shadowMargin],\n            [320 - shadowMargin - this.shadowCollisionRect.width, 176 - shadowMargin - this.shadowCollisionRect.height],\n            [shadowMargin, 176 - shadowMargin - this.shadowCollisionRect.height]\n        ];\n        var newShadowPlacement = shadowPlacements[Math.floor(Math.random() * shadowPlacements.length)];\n        this.shadowCollisionRect.x = newShadowPlacement[0];\n        this.shadowCollisionRect.y = newShadowPlacement[1];\n    };\n    Game.prototype.moveShadow = function () {\n        var playerCenterX = this.playerCollisionRect.x + this.playerCollisionRect.width / 2;\n        var playerCenterY = this.playerCollisionRect.y + this.playerCollisionRect.height / 2;\n        var shadowCenterX = this.shadowCollisionRect.x + this.shadowCollisionRect.width / 2;\n        var shadowCenterY = this.shadowCollisionRect.y + this.shadowCollisionRect.height / 2;\n        if (this.shadowSpeed <= Math.abs(playerCenterX - shadowCenterX)) {\n            this.shadowCollisionRect.x += (playerCenterX - shadowCenterX) / Math.abs(playerCenterX - shadowCenterX) * this.shadowSpeed;\n        }\n        else {\n            this.shadowCollisionRect.x += playerCenterX - shadowCenterX;\n        }\n        if (this.shadowSpeed <= Math.abs(playerCenterY - shadowCenterY)) {\n            this.shadowCollisionRect.y += (playerCenterY - shadowCenterY) / Math.abs(playerCenterY - shadowCenterY) * this.shadowSpeed;\n        }\n        else {\n            this.shadowCollisionRect.y += playerCenterY - shadowCenterY;\n        }\n    };\n    Game.prototype.createEnemies = function (n) {\n        var maxEnemyType = Math.floor(this.currentRoom.id / 10);\n        if (maxEnemyType > 2)\n            maxEnemyType = 2;\n        var i = 0;\n        while (i < n) {\n            var newEnemy = new _Enemy__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Math.floor(Math.random() * (maxEnemyType + 1)));\n            newEnemy.setPosition(Math.floor(Math.random() * (320 - newEnemy.collisionRect.width)), Math.floor(Math.random() * (176 - newEnemy.collisionRect.height)));\n            var isAbleToAddEnemy = true;\n            for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                var backgroundLine = _a[_i];\n                if (this.isCollisionDetected(newEnemy.collisionRect, backgroundLine)) {\n                    isAbleToAddEnemy = false;\n                    break;\n                }\n            }\n            if (isAbleToAddEnemy) {\n                for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                    var wall = _c[_b];\n                    if (this.isCollisionDetected(newEnemy.collisionRect, wall)) {\n                        isAbleToAddEnemy = false;\n                        break;\n                    }\n                }\n            }\n            if (isAbleToAddEnemy) {\n                for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\n                    var enemy = _e[_d];\n                    if (this.isCollisionDetected(newEnemy.collisionRect, enemy.collisionRect)) {\n                        isAbleToAddEnemy = false;\n                        break;\n                    }\n                }\n            }\n            if (isAbleToAddEnemy) {\n                this.enemies.push(newEnemy);\n                i++;\n            }\n        }\n    };\n    Game.prototype.placeKey = function () {\n        if (this.currentRoom.keyColor != \"\") {\n            var isAbleToPlaceKey = void 0;\n            do {\n                isAbleToPlaceKey = true;\n                this.keyCollisionRect = { x: Math.floor(Math.random() * (320 - 14)), y: Math.floor(Math.random() * (176 - 6)), width: 14, height: 6 };\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                    var backgroundLine = _a[_i];\n                    if (this.isCollisionDetected(this.keyCollisionRect, backgroundLine)) {\n                        isAbleToPlaceKey = false;\n                        break;\n                    }\n                }\n                if (isAbleToPlaceKey) {\n                    for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                        var wall = _c[_b];\n                        if (this.isCollisionDetected(this.keyCollisionRect, wall)) {\n                            isAbleToPlaceKey = false;\n                            break;\n                        }\n                    }\n                }\n            } while (!isAbleToPlaceKey);\n        }\n    };\n    Game.prototype.placeKeyHole = function () {\n        if (this.currentRoom.keyHoleColor != \"\") {\n            var isAbleToPlaceKeyHole = void 0;\n            do {\n                isAbleToPlaceKeyHole = true;\n                var keyHoleX = Math.floor(320 * Math.floor(Math.random() * 5) / 5 + 320 / 10 - 16 / 2);\n                var keyHoleY = Math.floor(176 * Math.floor(Math.random() * 3) / 3 + 176 / 6 - 13 / 2);\n                this.keyHoleCollisionRect = { x: keyHoleX, y: keyHoleY, width: 16, height: 13 };\n                for (var _i = 0, _a = this.roomBackground; _i < _a.length; _i++) {\n                    var backgroundLine = _a[_i];\n                    if (this.isCollisionDetected(this.keyHoleCollisionRect, backgroundLine)) {\n                        isAbleToPlaceKeyHole = false;\n                        break;\n                    }\n                }\n            } while (!isAbleToPlaceKeyHole);\n        }\n    };\n    Game.prototype.playerDetectAction = function (e) {\n        var _this = this;\n        var key = e.key;\n        if (key == \"Control\") {\n            var movementforceX = 0;\n            var movementforceY = 0;\n            if (this.playerMovementsObject.goRight) {\n                movementforceX = 1;\n            }\n            else if (this.playerMovementsObject.goLeft) {\n                movementforceX = -1;\n            }\n            clearInterval(this.playerMovementsObject.goLeft);\n            this.playerMovementsObject.goLeft = null;\n            clearInterval(this.playerMovementsObject.goRight);\n            this.playerMovementsObject.goRight = null;\n            if (this.playerMovementsObject.goUp) {\n                movementforceY = -1;\n            }\n            else if (this.playerMovementsObject.goDown) {\n                movementforceY = 1;\n            }\n            clearInterval(this.playerMovementsObject.goDown);\n            this.playerMovementsObject.goDown = null;\n            clearInterval(this.playerMovementsObject.goUp);\n            this.playerMovementsObject.goUp = null;\n            this.isFireModeOn = true;\n            if ((movementforceX != 0 || movementforceY != 0) && this.isGunLoaded && this.playerBullets.length < 2) {\n                this.firePlayerBullet([movementforceX, movementforceY]);\n            }\n        }\n        else if (this.isFireModeOn && this.isGunLoaded) {\n            if (this.playerBullets.length < 2) {\n                switch (key) {\n                    case \"ArrowRight\":\n                        this.firePlayerBullet([1, 0]);\n                        break;\n                    case \"ArrowLeft\":\n                        this.firePlayerBullet([-1, 0]);\n                        break;\n                    case \"ArrowUp\":\n                        this.firePlayerBullet([0, -1]);\n                        break;\n                    case \"ArrowDown\":\n                        this.firePlayerBullet([0, 1]);\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n        else if (key == \"ArrowDown\" && !this.playerMovementsObject.goDown) {\n            this.playerMovementsObject.goDown = setInterval(function () {\n                if (_this.playerCollisionRect.y <= 1080 - _this.playerCollisionRect.height - _this.playerSpeed) {\n                    _this.playerCollisionRect.y += _this.playerSpeed;\n                }\n            }, Math.floor(1000 / 60));\n        }\n        else if (key == \"ArrowUp\" && !this.playerMovementsObject.goUp) {\n            this.playerMovementsObject.goUp = setInterval(function () {\n                if (_this.playerCollisionRect.y > 0) {\n                    _this.playerCollisionRect.y -= _this.playerSpeed;\n                }\n            }, Math.floor(1000 / 60));\n        }\n        else if (key == \"ArrowRight\" && !this.playerMovementsObject.goRight) {\n            this.playerMovementsObject.goRight = setInterval(function () {\n                if (_this.playerCollisionRect.x <= 1920 - _this.playerCollisionRect.width - _this.playerSpeed) {\n                    _this.playerCollisionRect.x += _this.playerSpeed;\n                }\n            }, Math.floor(1000 / 60));\n        }\n        else if (key == \"ArrowLeft\" && !this.playerMovementsObject.goLeft) {\n            this.playerMovementsObject.goLeft = setInterval(function () {\n                if (_this.playerCollisionRect.x > 0) {\n                    _this.playerCollisionRect.x -= _this.playerSpeed;\n                }\n            }, Math.floor(1000 / 60));\n        }\n    };\n    Game.prototype.playerStopAction = function (e) {\n        var key = e.key;\n        if (key == \"Control\") {\n            this.isFireModeOn = false;\n        }\n        else if (key == \"ArrowDown\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goDown);\n            this.playerMovementsObject.goDown = null;\n        }\n        else if (key == \"ArrowUp\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goUp);\n            this.playerMovementsObject.goUp = null;\n        }\n        else if (key == \"ArrowRight\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goRight);\n            this.playerMovementsObject.goRight = null;\n        }\n        else if (key == \"ArrowLeft\") {\n            this.isGunLoaded = true;\n            clearInterval(this.playerMovementsObject.goLeft);\n            this.playerMovementsObject.goLeft = null;\n        }\n    };\n    Game.prototype.firePlayerBullet = function (movementForces) {\n        this.isGunLoaded = false;\n        var newBullet = new _Bullet__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.bulletsFired, movementForces);\n        var horizontalCenterDistance = (this.playerCollisionRect.width / 2 + newBullet.width / 2);\n        var verticalCenterDistance = (this.playerCollisionRect.height / 2 + newBullet.height / 2);\n        var newBulletX = Math.floor(this.playerCollisionRect.x + this.playerCollisionRect.width / 2 + horizontalCenterDistance * movementForces[0] - newBullet.width / 2);\n        var newBulletY = Math.floor(this.playerCollisionRect.y + this.playerCollisionRect.height / 2 + verticalCenterDistance * movementForces[1] - newBullet.height / 2);\n        newBullet.setCoords(newBulletX, newBulletY);\n        this.playerBullets.push(newBullet);\n        this.bulletsFired += 1;\n    };\n    Game.prototype.moveEnemies = function () {\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\n            var enemy = _a[_i];\n            if (enemy.type == 2) {\n                if (this.frame % 2 == 0) {\n                    var distanceX = (this.playerCollisionRect.x + this.playerCollisionRect.width / 2) - (enemy.collisionRect.x + enemy.collisionRect.width / 2);\n                    var distanceY = (this.playerCollisionRect.y + this.playerCollisionRect.height / 2) - (enemy.collisionRect.y + enemy.collisionRect.height / 2);\n                    if (Math.abs(distanceX) > enemy.speed) {\n                        distanceX = distanceX / Math.abs(distanceX) * enemy.speed;\n                    }\n                    if (Math.abs(distanceY) > enemy.speed) {\n                        distanceY = distanceY / Math.abs(distanceY) * enemy.speed;\n                    }\n                    var newCollisionRect = { x: enemy.collisionRect.x + distanceX, y: enemy.collisionRect.y + distanceY, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\n                    while (!this.canEnemyMove(enemy, newCollisionRect)) {\n                        if (Math.abs(distanceX) >= Math.abs(distanceY)) {\n                            distanceY = 0;\n                        }\n                        else {\n                            distanceX = 0;\n                        }\n                        newCollisionRect = { x: enemy.collisionRect.x + distanceX, y: enemy.collisionRect.y + distanceY, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\n                    }\n                    enemy.collisionRect = newCollisionRect;\n                }\n            }\n            else if (enemy.type == 1) {\n                if (this.frame - enemy.movementObject.endFrame >= 8) {\n                    // Start new movement\n                    if (this.canEnemySeePlayer(enemy)) {\n                        // Choose direction\n                        console.log('real move');\n                        var distanceX = (this.playerCollisionRect.x + this.playerCollisionRect.width / 2) - (enemy.collisionRect.x + enemy.collisionRect.width / 2);\n                        var distanceY = (this.playerCollisionRect.y + this.playerCollisionRect.height / 2) - (enemy.collisionRect.y + enemy.collisionRect.height / 2);\n                        if (Math.abs(distanceX) > Math.abs(distanceY)) {\n                            enemy.movementObject.forceX = distanceX / Math.abs(distanceX);\n                        }\n                        else {\n                            enemy.movementObject.forceY = distanceY / Math.abs(distanceY);\n                        }\n                    }\n                    else {\n                        // Random direction\n                        console.log('random move');\n                        var randOfFour = Math.floor(Math.random() * 4);\n                        if (randOfFour % 2 == 0) {\n                            enemy.movementObject.forceX = randOfFour - 1;\n                        }\n                        else {\n                            enemy.movementObject.forceY = randOfFour - 2;\n                        }\n                    }\n                    enemy.movementObject.endFrame = this.frame + 48 / enemy.speed;\n                }\n                else if (this.frame == enemy.movementObject.endFrame) {\n                    // Reset movement forces\n                    enemy.movementObject.forceX = 0;\n                    enemy.movementObject.forceY = 0;\n                }\n                else if (this.frame < enemy.movementObject.endFrame) {\n                    // Move if possible\n                    var newCollisionRect = { x: enemy.collisionRect.x + enemy.movementObject.forceX * enemy.speed, y: enemy.collisionRect.y + enemy.movementObject.forceY * enemy.speed, width: enemy.collisionRect.width, height: enemy.collisionRect.height };\n                    if (this.canEnemyMove(enemy, newCollisionRect)) {\n                        enemy.collisionRect = newCollisionRect;\n                    }\n                    else {\n                        // Stop movement\n                        enemy.movementObject.forceX = 0;\n                        enemy.movementObject.forceY = 0;\n                        enemy.movementObject.endFrame = this.frame;\n                    }\n                }\n            }\n            else {\n                // Horizontal\n                var horizontalDistance = this.playerCollisionRect.x - enemy.collisionRect.x;\n                for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x); i += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed) {\n                    var didHitWall = false;\n                    for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n                        var wall = _c[_b];\n                        if (this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\n                            didHitWall = true;\n                            horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                            break;\n                        }\n                    }\n                    if (!didHitWall) {\n                        for (var _d = 0, _e = this.enemies; _d < _e.length; _d++) {\n                            var encounteredEnemmy = _e[_d];\n                            if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x + i, y: enemy.collisionRect.y, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\n                                didHitWall = true;\n                                horizontalDistance = i - (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                                break;\n                            }\n                        }\n                    }\n                    if (didHitWall) {\n                        break;\n                    }\n                }\n                // Vertical\n                var verticalDistance = this.playerCollisionRect.y - enemy.collisionRect.y;\n                for (var i = 0; Math.abs(i) <= Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y); i += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed) {\n                    var didHitWall = false;\n                    for (var _f = 0, _g = this.currentRoom.wallCollisionRects; _f < _g.length; _f++) {\n                        var wall = _g[_f];\n                        if (this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, wall)) {\n                            didHitWall = true;\n                            verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                            break;\n                        }\n                    }\n                    if (!didHitWall) {\n                        for (var _h = 0, _j = this.enemies; _h < _j.length; _h++) {\n                            var encounteredEnemmy = _j[_h];\n                            if (!enemy.equals(encounteredEnemmy) && this.isCollisionDetected({ x: enemy.collisionRect.x, y: enemy.collisionRect.y + i, width: enemy.collisionRect.width, height: enemy.collisionRect.height }, encounteredEnemmy.collisionRect)) {\n                                didHitWall = true;\n                                verticalDistance = i - (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                                break;\n                            }\n                        }\n                    }\n                    if (didHitWall) {\n                        break;\n                    }\n                }\n                if (Math.abs(horizontalDistance) > Math.abs(verticalDistance) && Math.abs(horizontalDistance) >= this.playerSpeed) {\n                    // if(Math.abs(horizontalDistance) >= enemy.speed)\n                    enemy.collisionRect.x += (this.playerCollisionRect.x - enemy.collisionRect.x) / Math.abs(this.playerCollisionRect.x - enemy.collisionRect.x) * enemy.speed;\n                    // else\n                    //     enemy.collisionRect.x += Math.floor(horizontalDistance)\n                }\n                else if (Math.abs(verticalDistance) >= this.playerSpeed) {\n                    // if(Math.abs(verticalDistance) >= enemy.speed)\n                    enemy.collisionRect.y += (this.playerCollisionRect.y - enemy.collisionRect.y) / Math.abs(this.playerCollisionRect.y - enemy.collisionRect.y) * enemy.speed;\n                    // else\n                    //     enemy.collisionRect.y += Math.floor(verticalDistance)\n                }\n            }\n        }\n    };\n    Game.prototype.isNumberBetween = function (n, min, max) {\n        return n >= min && n <= max;\n    };\n    Game.prototype.isCollisionDetected = function (cr1, cr2) {\n        if (cr1.x + cr1.width > cr2.x\n            && cr1.x < cr2.x + cr2.width\n            && cr1.y + cr1.height > cr2.y\n            && cr1.y < cr2.y + cr2.height) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    Game.prototype.canEnemyMove = function (enemy, newCollisionRect) {\n        if (newCollisionRect.x < 0 || newCollisionRect.y < 0 || newCollisionRect.x + newCollisionRect.width > 320 || newCollisionRect.y + newCollisionRect.height > 176) {\n            return false;\n        }\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\n            var otherEnemy = _a[_i];\n            if (!otherEnemy.equals(enemy) && this.isCollisionDetected(otherEnemy.collisionRect, newCollisionRect)) {\n                return false;\n            }\n        }\n        for (var _b = 0, _c = this.currentRoom.wallCollisionRects; _b < _c.length; _b++) {\n            var wall = _c[_b];\n            if (this.isCollisionDetected(newCollisionRect, wall)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Game.prototype.canEnemySeePlayer = function (enemy) {\n        var enemyPoint = [enemy.collisionRect.x + enemy.collisionRect.width / 2, enemy.collisionRect.y + enemy.collisionRect.height / 2];\n        var playerPoint = [this.playerCollisionRect.x + this.playerCollisionRect.width / 2, this.playerCollisionRect.y + this.playerCollisionRect.height / 2];\n        var wallPoint1, wallPoint2;\n        for (var _i = 0, _a = this.currentRoom.wallCollisionRects; _i < _a.length; _i++) {\n            var wall = _a[_i];\n            wallPoint1 = [wall.x, wall.y];\n            wallPoint2 = [wall.x + wall.width, wall.y + wall.height];\n            if (this.isIntersectionDetected(enemyPoint, playerPoint, wallPoint1, wallPoint2))\n                return false;\n        }\n        return true;\n    };\n    Game.prototype.canEnemyShootPlayer = function (enemy) {\n        // [Finish]\n        var forceX = 0;\n        var forceY = 0;\n        var enemyCenterX = enemy.collisionRect.x + enemy.collisionRect.width / 2;\n        var enemyCenterY = enemy.collisionRect.y + enemy.collisionRect.height / 2;\n        if ((enemyCenterX < this.playerCollisionRect.x || enemyCenterX > this.playerCollisionRect.x + enemy.collisionRect.width)\n            && (enemyCenterY < this.playerCollisionRect.y || enemyCenterY > this.playerCollisionRect.y + enemy.collisionRect.height))\n            return false;\n        if (!this.canEnemySeePlayer(enemy))\n            return false;\n        var playerPointX;\n        var playerPointY;\n        if (enemyCenterX >= this.playerCollisionRect.x && enemyCenterX <= this.playerCollisionRect.x + this.playerCollisionRect.width) {\n            playerPointX = enemyCenterX;\n            playerPointY = this.playerCollisionRect.y + this.playerCollisionRect.height / 2;\n        }\n        else if (enemyCenterY >= this.playerCollisionRect.y && enemyCenterY <= this.playerCollisionRect.y + this.playerCollisionRect.height / 2) {\n            playerPointY = enemyCenterY;\n            playerPointX = this.playerCollisionRect.x + this.playerCollisionRect.width / 2;\n        }\n        // ALL WRONG\n        // Use difference instead of quotient\n        // else if(enemyCenterX/enemyCenterY >= this.playerCollisionRect.x/(this.playerCollisionRect.y + this.playerCollisionRect.height/2) \n        //     && enemyCenterX/enemyCenterY <= (this.playerCollisionRect.x + this.playerCollisionRect.width/2)/this.playerCollisionRect.y){\n        //         let xCandidate : number = this.playerCollisionRect.x\n        //         let yCandidate : number = this.playerCollisionRect.y + this.playerCollisionRect.height\n        //         while(xCandidate/yCandidate != enemyCenterX/enemyCenterY){\n        //             xCandidate += 1\n        //             yCandidate += this.playerCollisionRect.height/this.playerCollisionRect.width\n        //         }\n        //         playerPointX = xCandidate\n        //         playerPointY = yCandidate\n        // }\n        // else if()\n        else {\n            return false;\n        }\n        forceX = (playerPointX - enemyCenterX) / Math.abs(playerPointX - enemyCenterX);\n        forceY = (playerPointY - enemyCenterY) / Math.abs(playerPointY - enemyCenterY);\n        for (var _i = 0, _a = this.enemies; _i < _a.length; _i++) {\n            var otherEnemy = _a[_i];\n            if (!otherEnemy.equals(enemy)) {\n            }\n        }\n    };\n    Game.prototype.isIntersectionDetected = function (A, B, C, D) {\n        var v1 = this.vectorProduct(C, D, A);\n        var v2 = this.vectorProduct(C, D, B);\n        var v3 = this.vectorProduct(A, B, C);\n        var v4 = this.vectorProduct(A, B, D);\n        if ((v1 > 0 && v2 < 0 || v1 < 0 && v2 > 0) && (v3 > 0 && v4 < 0 || v3 < 0 && v4 > 0))\n            return true;\n        return false;\n    };\n    Game.prototype.vectorProduct = function (X, Y, Z) {\n        var x1 = Z[0] - X[0];\n        var y1 = Z[1] - X[1];\n        var x2 = Y[0] - X[0];\n        var y2 = Y[1] - X[1];\n        return x1 * y2 - x2 * y1;\n    };\n    Game.prototype.enemyArrayIncludes = function (enemyArray, enemyToCheck) {\n        for (var _i = 0, enemyArray_1 = enemyArray; _i < enemyArray_1.length; _i++) {\n            var enemy = enemyArray_1[_i];\n            if (enemyToCheck.equals(enemy))\n                return true;\n        }\n        return false;\n    };\n    Game.prototype.bulletArrayIncludes = function (bulletArray, bulletToCheck) {\n        for (var _i = 0, bulletArray_1 = bulletArray; _i < bulletArray_1.length; _i++) {\n            var bullet = bulletArray_1[_i];\n            if (bulletToCheck.id == bullet.id)\n                return true;\n        }\n        return false;\n    };\n    Game.prototype.canReallyAnimate = function () {\n        return this.animationFrame % 6 == 0;\n    };\n    return Game;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Game);\n\n\n//# sourceURL=webpack://shamus/./src/Game.ts?");

/***/ }),

/***/ "./src/Room.ts":
/*!*********************!*\
  !*** ./src/Room.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Room = /** @class */ (function () {\n    function Room(id, levelColor, bgColor, wallCollisionRects, neighbourRoomsIds, keyColor, keyHoleColor) {\n        this.id = id;\n        this.levelColor = levelColor;\n        this.bgColor = bgColor;\n        this.wallCollisionRects = wallCollisionRects;\n        this.neighbourRoomsIds = neighbourRoomsIds;\n        this.keyColor = keyColor;\n        this.keyHoleColor = keyHoleColor;\n    }\n    return Room;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Room);\n\n\n//# sourceURL=webpack://shamus/./src/Room.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Game */ \"./src/Game.ts\");\n\nvar newGame = new _Game__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n\n//# sourceURL=webpack://shamus/./src/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;